# 代码质量

## TreeSharking

依赖于静态的ES6的模块化，去除未使用代码

### webpack配置

1. mode: production
2. optimization.usedExports: true
3. optimization.minimize: true

production模式下，后两个条件自动为 

develpoment下js的tree shaking是不生效的

```js
const config = {
    mode: 'production',
    optimization: {
        usedExports: true,
        minimize: true
        // 或指定特定的minifier时
        // minimizer: [                
        // new TerserPlugin({...})
        //]
    }
};
```

### 副作用

在做tree shaking时，webpack 会移出未 import 过或未使用的代码

但有些代码虽然未import， 但可能内部定义了全局变量，或者 它是全局CSS文件

```json
// 所有代码有副作用
{
 "sideEffects": true
}
// 所有代码没有副作用
{
 "sideEffects": false
}
// 地址数组，指定特定有副作用的文件集合
{
 "sideEffects": [
  "./src/file1.js",
  "./src/file2.js"
 ]
}
```

### TreeSharking适配

Npm大部分的包都是CommonJS，不支持

但是这些库提供CommonJS和ES6的代码，利用mainFields来配置使用ES6的方式

## Scope Hoisting

通过ES6语法静态分析，将模块尽可能的放到统一函数中，即多文件合并为一个文件

提升具有以下优势
1. 代码体积小
2. 作用域变少，内存开销减少

### Scope Hoisting设置方式

Webpack自带的ModuleConcatenationPlugin插件，配置即可

```js
// webpack.config.js
module.exports = {
    optimization: {
        concatenateModules: true
    }
};
```

但是由于只支持ES6模块化，mainFields设置优先使用ES6的依赖代码

```js
resolve: {
    mainFields: ['jsnext:main', 'browser', 'main']
}
```

## Prepack

按照执行结果生成最简化代码，但是局限大，不适合线上环境
