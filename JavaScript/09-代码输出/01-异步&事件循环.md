# 异步&事件循环

这个相关的问题推荐看以下笔记
1. [浏览器原理/进程和线程](../../浏览器原理/02-进程和线程.md)
2. [浏览器原理/事件循环](../../浏览器原理/04-事件循环.md)
3. [JavaScript/异步编程](../index.md)

## 01

```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    console.log(2);
});
promise.then(() => {
    console.log(3);
});
console.log(4);

/// 打印内容
// 1
// 2
// 4
```

由于promise内部并未调用resolve或reject，所以一直处于pending状态，从而then不会触发

## 02

```js
const promise1 = new Promise((resolve, reject) => {
    console.log('promise1') // 1
    resolve('resolve1')
})
const promise2 = promise1.then(res => {
    console.log(res) // 4
})
console.log('1', promise1); // 2
console.log('2', promise2); // 3

/// 打印内容
// promise1
// 1 Promise {<fulfilled>: 'resolve1'}
// 2 Promise {<pending>}
// resolve1
```

1. 第一遍同步执行1，2，3的console
   1. promise1为fulfilled，是因为已经resolve了
   2. promise2为pending，是因为then中没有返回值
2. 同步执行完成，处理微任务执行4的console

## 03

```js
Promise.resolve().then(() => {
    console.log('promise1');
    const timer2 = setTimeout(() => {
        console.log('timer2')
    }, 0)
});
const timer1 = setTimeout(() => {
    console.log('timer1')
    Promise.resolve().then(() => {
        console.log('promise2')
    })
}, 0)
console.log('start');

/// 打印内容
// start
// promise1
// timer1
// promise2
// timer2
```

1. 第一次事件循环
   1. promise1的then微任务注册
   2. timer1的宏任务注册
   3. 打印start
   4. 执行微任务
      1. 打印promise1
      2. 注册timer2的宏任务
2. 第二次事件循环（timer1宏任务）
   1. 打印timer1
   2. 注册promise2微任务
   3. 清空微任务
      1. 打印promise2
3. 第三次事件循环（timer2宏任务）
   1. 单元timer2
