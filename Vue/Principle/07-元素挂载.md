# 元素挂载

## 挂载入口

1. $mount执行mountComponent
    1. 创建updateComponent：()=>{  vm._update(vm._render(), hydrating) }
    2. 创建renderWatcher，并将updateComponent作为expOrFn传入
    3. renderWatcher的constructor结尾执行updateComponent进行挂载
        1. _render执行获取vnode(renderMixin时设置)
        2. _update执行挂载元素(lifecycleMixin时设置)

## _render()

1. 执行render.call(vm._renderProxy, vm.$createElement)，获取vnode并返回
2. render生成元素主要靠_c生成vnode
3. 其中`vm.$vnode` === `vnode.parent` === `vm.$options._parentVnode`

### render函数执行方法设置

1. _c在_init中执行initRender设置：_c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
2. 其它的renderMixin中执行installRenderHelpers(Vue.prototype)
    1. _l：渲染List
    2. _t：渲染slot
    3. ...

### createElement(context, tag, data, children, normalizationType, alwaysNormalize)

1. 处理传入参数
2. 执行_createElement生成Vnode

### _createElement(context, tag, data, children, normalizationType)

1. 异常节点拦截，返回空Vnode
    1. observed的data对象拦截
    2. tag获取和异常拦截
2. vnode创建
    1. tag为字符串
        1. HTML标签或者SVG标签直接创建新的vnode
        2. 组件创建调用createComponent
        3. 其他的则是直接按照传入的tag创建vnode
    2. tag为函数
        1. 直接tag当作Ctor，利用createComponent创建组件

## _update(vnode, hydrating)

1. 获取prevVnode，判断是否存在，不同方式执行，并将结果设置为vm.$el
    1. 存在，则首次渲染，执行`vm.__patch__(vm.$el, vnode, hydrating, false)`
    2. 不存在，则后续更新，执行`vm.__patch__(prevVnode, vnode)`

### patch(oldVnode, vnode, hydrating, removeOnly)

1. vnode未定义 => 销毁oldVnode，并直接返回
2. oldVnode未定义 => 首次渲染，直接createElm创建新元素并挂载
3. vnode与oldVnode都存在，执行更新处理
    1. sameVnode(oldVnode, vnode)为true，执行patchVnode
    2. 否则直接createElm创建新元素并替换

### patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly)

1. oldVnode === vnode则直接返回
2. 非文本标签处理
    1. 新旧孩子都有，调用updateChildren使用diff更新孩子
    2. 仅有新孩子，直接添加新孩子
    3. 仅有旧孩子，直接删除旧孩子
3. 文本标签，则直接替换

### updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly)

1. 新旧节点的开始结束的idx设置
2. 按照idx设置新旧的开始和结束vnode
3. while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx)
    1. 旧节点为空处理
        1. 旧开始节点为空，oldStartIdx加一并更新oldStartVnode
        2. 旧结束节点为空，oldEndIdx减一并更新oldEndVnode
    2. 头头相同，头节点后移
        1. patchVnode(oldStartVnode, newStartVnode, ...)
        2. oldStartVnode = oldCh[++oldStartIdx]
        3. newStartVnode = newCh[++newStartIdx]
    3. 尾尾相同，尾节点前移
        1. patchVnode(oldEndVnode, newEndVnode, ...)
        2. oldEndVnode = oldCh[--oldEndIdx]
        3. newEndVnode = newCh[--newEndIdx]
    4. 头尾相同，右移，旧头节点移动至旧尾节点后，头节点后移，尾节点前移
        1. patchVnode(oldStartVnode, newEndVnode, ...)
        2. oldEndVnode = oldCh[--oldEndIdx]
        3. newEndVnode = newCh[--newEndIdx]
    5. 尾头相同，左移，旧尾节点移动至旧头节点前，头节点后移，尾节点前移
        1. patchVnode(oldEndVnode, newStartVnode, ...)
        2. oldEndVnode = oldCh[--oldEndIdx]
        3. newEndVnode = newCh[--newEndIdx]
    6. 乱序处理
        1. newStartVnode.key获取旧节点映射oldKeyToIdx
        2. 获取映射中与oldKeyToIdx对应的idxInOld
        3. 是否存在映射的值
            1. 不存在直接创建节点，并插到旧头节点之前
            2. 存在，则获取节点，看sameVnode(vnodeToMove, newStartVnode)
                1. 相同，则执行patchVnode处理
                2. 不同创建新节点
        4. newStartVnode = newCh[++newStartIdx]
4. 剩余节点处理
   1. 新节点剩余（oldStartIdx > oldEndIdx），添加新节点
   2. 旧节点剩余（newStartIdx > newEndIdx），删除旧节点

### createElm( vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index)

1. 组件处理：createComponent(vnode, insertedVnodeQueue, parentElm, refElm)，为true直接返回
2. 通过vnode生成元素
    1. tag定义了
        1. 通过nodeOps.createElement传入vnode生成标签，并设置为vnode.elm
        2. 处理children标签生成
        3. 将vnode.elm插入到父元素中
    2. tag未定义
        1. isTrue(vnode.isComment)
            1. 则nodeOps.createComment生成标签，并设置为vnode.elm
            2. 将vnode.elm插入到父元素中
        2. 否则直接nodeOps.createTextNode，创建文本标签并设置为vnode.elm，同时插入到父元素中
