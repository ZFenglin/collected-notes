<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"Promise","c":[{"t":"heading","d":2,"p":{"lines":[2,3]},"v":"Promise概念","c":[{"t":"heading","d":3,"p":{"lines":[4,5]},"v":"三个状态","c":[{"t":"list_item","d":5,"p":{"lines":[6,7],"index":1},"v":"1. pending（待定）"},{"t":"list_item","d":5,"p":{"lines":[7,8],"index":2},"v":"2. fullfilled（兑现，也有resolved）"},{"t":"list_item","d":5,"p":{"lines":[8,9],"index":3},"v":"3. rejected（拒绝）"}]},{"t":"heading","d":3,"p":{"lines":[10,11]},"v":"两个过程","c":[{"t":"ordered_list","d":4,"p":{"lines":[12,15],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[12,13],"index":1},"v":"1. pending =&gt; resolve（触发onFulfilled）"},{"t":"list_item","d":5,"p":{"lines":[13,14],"index":2},"v":"2. pending =&gt; rejected（触发onRejected）"}]},{"t":"heading","d":4,"p":{"lines":[15,16]},"v":"过程特点","c":[{"t":"list_item","d":6,"p":{"lines":[17,18],"index":3},"v":"3. 变化不可逆"},{"t":"list_item","d":6,"p":{"lines":[18,19],"index":4},"v":"4. 结果事件将会放在微任务队列中等待执行"}]}]}]},{"t":"heading","d":2,"p":{"lines":[20,21]},"v":"Promise方法","c":[{"t":"heading","d":3,"p":{"lines":[22,23]},"v":"构造函数","c":[{"t":"heading","d":4,"p":{"lines":[24,25]},"v":"Promise()"}]},{"t":"heading","d":3,"p":{"lines":[28,29]},"v":"实例方法(Promise.prototype)","c":[{"t":"heading","d":4,"p":{"lines":[30,31]},"v":".then","c":[{"t":"list_item","d":6,"p":{"lines":[34,35],"index":1},"v":"1. then会返回一个全新的Promise对象"},{"t":"list_item","d":6,"p":{"lines":[35,36],"index":2},"v":"2. then方法就是为上一个then返回Promise注册回调"},{"t":"list_item","d":6,"p":{"lines":[36,37],"index":3},"v":"3. then的返回值会作为后续的then方法的回调参数"}]},{"t":"heading","d":4,"p":{"lines":[38,39]},"v":".catch"},{"t":"heading","d":4,"p":{"lines":[42,43]},"v":".finally"}]},{"t":"heading","d":3,"p":{"lines":[46,47]},"v":"静态方法(Promise)","c":[{"t":"heading","d":4,"p":{"lines":[48,49]},"v":"Promise.all(iterable)","c":[{"t":"heading","d":5,"p":{"lines":[54,55]},"v":"手写Promise.all(iterable)","c":[{"t":"fence","d":6,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">function promiseAll(promises) {\n    return new Promise(function(resolve, reject) {\n        // 类型判断\n        if (!Array.isArray(promises)) {\n            throw new TypeError('promise must be a array')\n        }\n        let count = 0\n        let length = promises.length\n        let promisesResults = []\n        for (let index = 0; index &lt; length; index++) {\n            // 用Promise.resolve包裹传入promise参数，防止传入普通函数报错\n            const promise = promises[index];\n            Promise.resolve(promise).then(\n                res =&gt; {\n                    count++\n                    promisesResults[index] = res\n                    if (count === length) {\n                        return resolve(promisesResults)\n                    }\n                },\n                res =&gt; {\n                    return reject(res)\n                },\n            )\n        }\n    })\n}\n</code></pre>\n"}]}]},{"t":"heading","d":4,"p":{"lines":[86,87]},"v":"Promise.allSettled(iterable)"},{"t":"heading","d":4,"p":{"lines":[90,91]},"v":"Promise.any(iterable)"},{"t":"heading","d":4,"p":{"lines":[94,95]},"v":"Promise.race(iterable)","c":[{"t":"heading","d":5,"p":{"lines":[98,99]},"v":"手写Promise.race","c":[{"t":"fence","d":6,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">function promiseRace(promises) {\n    return new Promise((resolve, reject) =&gt; {\n        // 类型判断\n        if (!Array.isArray(promises)) {\n            throw new TypeError('promise must be a array')\n        }\n        for (let index = 0; index &lt; promises.length; index++) {\n            const promise = promises[index];\n            Promise.resolve(promise).then(\n                res =&gt; {\n                    return resolve(res)\n                },\n                res =&gt; {\n                    return reject(res)\n                },\n            )\n        }\n    })\n}\n</code></pre>\n"}]},{"t":"heading","d":5,"p":{"lines":[122,123]},"v":"Promise.race实现执行中断","c":[{"t":"fence","d":6,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">Promise.race([promise1, timeOutPromise(5000)]).then(res =&gt; {})\n</code></pre>\n"}]}]},{"t":"heading","d":4,"p":{"lines":[130,131]},"v":"Promise.reject(reason)"},{"t":"heading","d":4,"p":{"lines":[134,135]},"v":"Promise.resolve(value)","c":[{"t":"list_item","d":6,"p":{"lines":[138,139],"index":1},"v":"1. value为带有then方法的对象：返回的Promise对象的最终状态由then方法执行决定"},{"t":"list_item","d":6,"p":{"lines":[139,140],"index":2},"v":"2. value为其他：返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法"}]}]}]},{"t":"heading","d":2,"p":{"lines":[141,142]},"v":"链式调用","c":[{"t":"heading","d":3,"p":{"lines":[145,146]},"v":"Promise执行方法判断","c":[{"t":"list_item","d":5,"p":{"lines":[151,152],"index":1},"v":"1. 当没有设定状态时，默认状态是resolved，触发最近的then"},{"t":"list_item","d":5,"p":{"lines":[152,153],"index":2},"v":"2. 当内部报错时，默认状态为rejected，触发最近的catch"}]},{"t":"heading","d":3,"p":{"lines":[154,155]},"v":"<a href=\"https://juejin.cn/post/6844903987183894535\">执行顺序判断</a>","c":[{"t":"ordered_list","d":4,"p":{"lines":[156,159],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[156,157],"index":1},"v":"1. 微任务回调事件按照注册顺序执行"},{"t":"list_item","d":5,"p":{"lines":[157,158],"index":2},"v":"2. 任何一个异常都会不断向后执行直到捕获"}]},{"t":"heading","d":4,"p":{"lines":[159,160]},"v":"then与catch的注册时机","c":[{"t":"fence","d":5,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">// 所有then同时注册\n// 1. 先创建Promise实例\nlet p = new Promise()\np.then(() {})\np.then(() {})\n// 2. return直接返回Promise实例\nreturn new Promise().then(() {}).then(() {})\n</code></pre>\n"},{"t":"fence","d":5,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">// 按照回调执行后注册\n// 会等待第一个then执行完后再注册第二个\nnew Promise().then(() {}).then(() {})\n</code></pre>\n"}]}]}]},{"t":"heading","d":2,"p":{"lines":[177,178]},"v":"手写Promise","c":[{"t":"ordered_list","d":3,"p":{"lines":[179,185],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[179,180],"index":1},"v":"1. 利用数组保存回调"},{"t":"list_item","d":4,"p":{"lines":[180,181],"index":2},"v":"2. 在下一个循环执行resolve和reject"},{"t":"list_item","d":4,"p":{"lines":[181,182],"index":3},"v":"3. 按照执行结果是否instanceof _Promise，决定是否继续执行then"},{"t":"list_item","d":4,"p":{"lines":[182,183],"index":4},"v":"4. then返回一个_Promise对象"},{"t":"list_item","d":4,"p":{"lines":[183,184],"index":5},"v":"5. catch返回一个只注册onRejected的then的执行结果"}]},{"t":"fence","d":3,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">class _Promise {\n    static PENDING = '待定'\n    static FULFILLED = '兑现'\n    static REJECTED = '拒绝'\n\n    status = _Promise.PENDING\n    result = undefined\n    resolveCallbacks = []\n    rejectCallbacks = []\n\n    constructor(executor) {\n        const resolve = (value) =&gt; {\n            setTimeout(() =&gt; {\n                if (this.status === _Promise.PENDING) {\n                    this.status = _Promise.FULFILLED\n                    this.result = value\n                    this.resolveCallbacks.forEach(cb =&gt; cb())\n                }\n            });\n        }\n        const reject = (value) =&gt; {\n            setTimeout(() =&gt; {\n                if (this.status === _Promise.PENDING) {\n                    this.status = _Promise.REJECTED\n                    this.result = value\n                    this.rejectCallbacks.forEach(cb =&gt; cb())\n                }\n            });\n        }\n        try {\n            executor(resolve, reject)\n        } catch (error) {\n            reject(error)\n        }\n    }\n\n    handlePromise(fn, resolve, reject, resolved = true) {\n        try {\n            let x = fn(this.result)\n            if (x instanceof _Promise) {\n                x.then(resolve, reject)\n            } else {\n                resolved ? resolve(x) : reject(x)\n            }\n        } catch (error) {\n            reject(error)\n        }\n    }\n\n    then(onResolved, onRejected) {\n        return new _Promise((resolve, reject) =&gt; {\n            let resolvedFn = typeof onResolved === 'function' ? () =&gt; this.handlePromise(onResolved, resolve, reject, true) : () =&gt; {}\n            let rejectedFn = typeof onRejected === 'function' ? () =&gt; this.handlePromise(onRejected, resolve, reject, false) : () =&gt; {}\n            switch (this.status) {\n                case _Promise.FULFILLED:\n                    resolvedFn()\n                    break;\n                case _Promise.REJECTED:\n                    rejectedFn()\n                    break;\n                case _Promise.PENDING:\n                    this.resolveCallbacks.push(() =&gt; resolvedFn())\n                    this.rejectCallbacks.push(() =&gt; rejectedFn())\n                    break;\n            }\n        })\n    }\n\n    catch (onRejected) {\n        return this.then(null, onRejected)\n    }\n}\n</code></pre>\n"}]}]})</script>
</body>
</html>
