<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"async和await","c":[{"t":"heading","d":2,"p":{"lines":[4,5]},"v":"相互关系","c":[{"t":"heading","d":3,"p":{"lines":[6,7]},"v":"与Promise关系","c":[{"t":"list_item","d":5,"p":{"lines":[8,9],"index":1},"v":"1. async：会将函数封装成Promise.resolve对象"},{"t":"list_item","d":5,"p":{"lines":[9,10],"index":2},"v":"2. await：后续代码等价于Promise的then"},{"t":"list_item","d":5,"p":{"lines":[10,11],"index":3},"v":"3. try...catch：等价于Promise的catch"}]},{"t":"heading","d":3,"p":{"lines":[12,13]},"v":"与generator关系","c":[{"t":"ordered_list","d":4,"p":{"lines":[14,17],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[14,15],"index":1},"v":"1. await替代yield"},{"t":"list_item","d":5,"p":{"lines":[15,16],"index":2},"v":"2. 自带生成器执行器"}]},{"t":"heading","d":4,"p":{"lines":[17,18]},"v":"与generator的区别","c":[{"t":"list_item","d":6,"p":{"lines":[19,20],"index":1},"v":"1. async/await自带执行器，不需要手动调用next()"},{"t":"list_item","d":6,"p":{"lines":[20,21],"index":2},"v":"2. async函数返回值是Promise对象，而Generator返回的是生成器对象"}]}]}]},{"t":"heading","d":2,"p":{"lines":[22,23]},"v":"是否支持await的遍历","c":[{"t":"heading","d":3,"p":{"lines":[24,25]},"v":"同步遍历（不支持await）","c":[{"t":"list_item","d":5,"p":{"lines":[26,27],"index":1},"v":"1. for...in"},{"t":"list_item","d":5,"p":{"lines":[27,28],"index":2},"v":"2. forEach"}]},{"t":"heading","d":3,"p":{"lines":[29,30]},"v":"异步遍历","c":[{"t":"list_item","d":5,"p":{"lines":[31,32],"index":1},"v":"1. for...of"}]}]},{"t":"heading","d":2,"p":{"lines":[33,34]},"v":"Iterator","c":[{"t":"heading","d":3,"p":{"lines":[37,38]},"v":"for...of","c":[{"t":"heading","d":4,"p":{"lines":[39,40]},"v":"处理支持for...of","c":[{"t":"list_item","d":6,"p":{"lines":[43,44],"index":1},"v":"1. 类数组对象则直接Array.from转成数组"},{"t":"list_item","d":6,"p":{"lines":[44,45],"index":2},"v":"2. 给对象添加一个Symbol.iterator属性"}]},{"t":"heading","d":4,"p":{"lines":[46,47]},"v":"与for...in差异","c":[{"t":"list_item","d":6,"p":{"lines":[48,49],"index":1},"v":"1. 获取值","c":[{"t":"list_item","d":8,"p":{"lines":[49,50],"index":1},"v":"1. for…in 获取的是对象的键名"},{"t":"list_item","d":8,"p":{"lines":[50,51],"index":2},"v":"2. for…of 遍历获取的是对象的键值"}]},{"t":"list_item","d":6,"p":{"lines":[51,52],"index":2},"v":"2. 遍历范围","c":[{"t":"list_item","d":8,"p":{"lines":[52,53],"index":1},"v":"1. for…in 会遍历对象的整个原型链，性能非常差不推荐使用"},{"t":"list_item","d":8,"p":{"lines":[53,54],"index":2},"v":"2. for…of 只遍历当前对象不会遍历原型链"}]},{"t":"list_item","d":6,"p":{"lines":[54,55],"index":3},"v":"3. 数组遍历","c":[{"t":"list_item","d":8,"p":{"lines":[55,56],"index":1},"v":"1. for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)"},{"t":"list_item","d":8,"p":{"lines":[56,57],"index":2},"v":"2. for…of 只返回数组的下标对应的属性值"}]}]}]},{"t":"heading","d":3,"p":{"lines":[58,59]},"v":"实现迭代器接口","c":[{"t":"list_item","d":5,"p":{"lines":[60,61],"index":1},"v":"1. 对象增加Symbol.iterator方法，返回具有next方法的对象并且对象next方法返回具有value和done的对象"},{"t":"list_item","d":5,"p":{"lines":[61,62],"index":2},"v":"2. 利用生成器，由于执行 Generator 函数实际返回的是一个遍历器，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口"}]}]},{"t":"heading","d":2,"p":{"lines":[63,64]},"v":"<a href=\"https://www.cnblogs.com/rogerwu/p/10764046.html\">Generator</a>","c":[{"t":"heading","d":3,"p":{"lines":[67,68]},"v":"生成器语法","c":[{"t":"heading","d":4,"p":{"lines":[69,70]},"v":"创建生成器","c":[{"t":"fence","d":5,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">function* generator()\n</code></pre>\n"},{"t":"ordered_list","d":5,"p":{"lines":[75,79],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[75,76],"index":1},"v":"1. function关键字与函数名之间有一个星号"},{"t":"list_item","d":6,"p":{"lines":[76,77],"index":2},"v":"2. Generator函数并不会执行，而是返回一个生成器对象"},{"t":"list_item","d":6,"p":{"lines":[77,78],"index":3},"v":"3. 调用next执行到下一个yield"}]}]},{"t":"heading","d":4,"p":{"lines":[79,80]},"v":"yield","c":[{"t":"list_item","d":6,"p":{"lines":[81,82],"index":1},"v":"1. 使用yield表达式，定义不同的内部状态"},{"t":"list_item","d":6,"p":{"lines":[82,83],"index":2},"v":"2. 执行完一条yield语句后函数就会自动停止执行，直到再次调用next()"},{"t":"list_item","d":6,"p":{"lines":[83,84],"index":3},"v":"3. yield*，则可以Generator函数里面调用另一个Generator 函数"}]}]},{"t":"heading","d":3,"p":{"lines":[85,86]},"v":"生成器方法","c":[{"t":"heading","d":4,"p":{"lines":[87,88]},"v":"Generator.prototype.next()"},{"t":"heading","d":4,"p":{"lines":[93,94]},"v":"Generator.prototype.return()"},{"t":"heading","d":4,"p":{"lines":[97,98]},"v":"Generator.prototype.throw()"}]},{"t":"heading","d":3,"p":{"lines":[101,102]},"v":"生成器执行器","c":[{"t":"fence","d":4,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">function readFile(url) {\n    return new Promise(function(resolve, reject) {\n        fs.readFile(url, function(error, data) {\n            if (error) reject(error);\n            resolve(data)\n        })\n    })\n}\nfunction* gen() {\n    var f1 = yield readFile('./a.txt');\n    console.log(f1)\n    var f2 = yield readFile('./b.txt');\n    console.log(f2)\n\n}\nfunction co(generator) {\n    const iterator = generator();\n    return new Promise(function(resolve, reject) {\n        // 通过递归的方式遍历内部状态\n        function diff(value) {\n            ret = iterator.next(value);\n            if (ret.done) return resolve(ret.value);\n            Promise.resolve(ret.value).then(function(data) {\n                diff(data.toString())\n            });\n        }\n        try {\n            diff()\n        } catch (err) {\n            reject(err)\n        }\n    })\n\n}\nco(gen)\n</code></pre>\n"}]}]}]})</script>
</body>
</html>
