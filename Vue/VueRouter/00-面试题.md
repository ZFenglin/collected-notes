# 面试题

## 前端路由理解

### 出现的前提

1. AJAX出现，允许不刷新浏览器的情况下更新页面，促使SPA出现
2. SPA存在问题
   1. 不会记住用户操作
   2. SEO不友好

#### 两个问题

1. SPA无法记住用户操作问题
2. 用户刷新页面如何不重复加载资源（服务端已经无法解决）

#### 前端路解决思路

1. 前端拦截用户刷新
2. 感知URL变化，渲染不同页面

## 路由模式

### hash模式（默认）

1. hash模式是开发中默认的模式，它的URL带着一个#
2. hash模式特点
    1. hash值会出现在URL中，但是不会在HTTP请求中，浏览器的前进后退不会请求服务器
    2. hash值的改动不会重新加载页面
    3. 浏览器支持度好
    4. 前端自测推荐hash

```js
// hash的监听
const eventType = supportsPushState ? 'popstate' : 'hashchange'
window.addEventListener(eventType, handleRoutingEvent)
```

### history模式

1. 传统路由分发模式，用户在输入一个URL时，服务器会接收这个请求，并解析这个URL
2. history模式特点
    1. 没有#更美观
    2. 会发起请求，需要后台支持，没有配置正确则会返回404

```js
// history监听
window.addEventListener('popstate', handleRoutingEvent)
```

### 更改URL

#### 相关浏览器API

1. 修改历史状态，但是页面不会刷新
   1. pushState()
   2. replaceState()
2. 切换历史状态
   1. forward()
   2. back()
   3. go()

#### hash

hash利用pushHash处理url更改

1. 优先pushState
2. 不支持则window.location.hash直接修改

```js
function pushHash(path) {
    if (supportsPushState) {
        pushState(getUrl(path))
    } else {
        window.location.hash = path
    }
}
```

#### history

history则直接使用pushState

```js
pushState(cleanPath(this.base + route.fullPath))
```

#### 修改方式比较

无论哪种方式，修改地址只有两种方式

1. history.pushState()
    1. 设置的新 URL 可以是与当前 URL 同源的任意 URL
    2. 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中
    3. 通过 stateObject 参数可以添加任意类型的数据到记录中
    4. 前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误
    5. 可额外设置 title 属性供后续使用
2. 直接修改window.location.hash
    1. 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL
    2. hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中
    3. hash 只可添加短字符串
    4. 仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误

## 路由跳转方式

### param方式

1. 不会对路径进行修改
2. 并且需要命名的路由，让路由建立 url（即声明路由时需要name属性）

#### param跳转

```html
<router-link :to="{ name: 'user', params: { username: 'eduardo' }}" />
```

```js
this.$router.push({
    name: 'user',
    params: {
        username: 'eduardo'
    }
})
```

#### param参数

```js
this.$route.params.username
```

### query方式

会修改路径，形如/user?username=eduardo

#### query跳转

```html
<router-link :to="{ name: '/user', query: { username: 'eduardo' }}">
```

```js
this.$router.push({
    name: '/user',
    query: {
        username: 'eduardo'
    }
})

this.$router.push('/user?username=' + 'eduardo')
```

#### query参数

```js
this.$route.query.username
```

### params和query的区别

1. 用法
   1. params要用name来引入
   2. query要用path来引入
2. url地址显示
   1. params则类似于post
   2. query更加类似于get
3. 刷新数据丢失
   1. params刷新会丢失params里面的数据
   2. query刷新不会丢失query里面的数据

## 路由守卫

### 守卫分类

1. 全局前置/钩子（页面权限拦截）
    1. router.beforeEach：全局前置守卫
    2. router.beforeResolve：全局解析守卫，beforeRouteEnter调用后调用
    3. router.afterEach：全局后置钩子
2. 路由独享的守卫
    1. 配置路由时添加
    2. 只有beforeEnter，有三个参数∶ to、from、next
3. 组件内的守卫（很少使用）
    1. beforeRouteEnter：进入组件前触发，访问不到this，因为该守卫执行前组件实例还没有被创建，传一个回调给 next来访问
    2. beforeRouteUpdate：当前地址改变并且组件被复用时触发，/foo/1 和 /foo/2 之间跳转时会触发
    3. beforeRouteLeave：离开组件被调用

### 执行流程（A页面=>B页面）

#### 解析b组件前

1. 触发进入其他路由
2. beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开
3. beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等
4. beforeRouteUpdate：在重用的组件里调用（2.2+）
5. beforeEnter：路由独享守卫

#### 解析b组件

1. 解析异步路由组件
2. beforeRouteEnter：路由组件的组件进入路由前钩子
3. beforeResolve：路由全局解析守卫（2.5+），标示解析阶段完成，此时导航被确认
4. afterEach：路由后置全局钩子

#### b组件生命周期

1. 非重用组件，开始组件实例的生命周期：beforeCreate、created、beforeMount、（此处开始执行a的beforeDestroy和destroyed）、mounted
2. 触发 DOM 更新
3. 用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数
4. 导航完成

## 动态路由

将定匹配模式的路由映射到同一个组件

```js
const routes = [
    // 动态字段以冒号开始
    {
        path: '/users/:id',
        component: User
    },
]
```

其匹配的规则如下

```js
// 匹配模式
'/users/:username/posts/:postId' => '/users/eduardo/posts/123'
// $route.params
{
    username: 'eduardo',
    postId: '123'
}
```

由于支持正则，当然也可用用于404页面匹配

```js
const routes = [
    // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下
    {
        path: '/:pathMatch(.*)*',
        name: 'NotFound',
        component: NotFound
    },
    // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下
    {
        path: '/user-:afterUser(.*)',
        component: UserGeneric
    },
]
```

## 其它

### 路由懒加载

箭头函数+import动态加载

```js
() => import('@/components/list.vue')
```

箭头函数+require动态加载

```js
resolve => require(['@/components/list'], resolve)
```

使用webpack的require.ensure技术，多个路由指定相同的chunkName则会打包到一个js文件中

```js
r => require.ensure([], () => r(require('@/components/list')), 'list')
```

### 如何获取页面hash变化

1. watch深度监听$route的变化
2. window.location.hash读取#值

### `$route` 和 `$router` 的区别

1. $route：路由信息对象具有path，params，hash，query，fullPath，matched，name 等路由信息参数
2. $router：路由实例，包括了路由的跳转方法，钩子函数等

### Vue-router跳转和location.href区别

1. location.href= /url会造成页面刷新
2. history.pushState( /url )，仅改变URL，不刷新页面，vue-router使用的方式
