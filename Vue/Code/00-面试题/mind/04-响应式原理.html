<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"响应式原理","c":[{"t":"heading","d":2,"p":{"lines":[2,3]},"v":"双向绑定原理","c":[{"t":"heading","d":3,"p":{"lines":[8,9]},"v":"observe","c":[{"t":"list_item","d":5,"p":{"lines":[11,12],"index":1},"v":"1. getter：触发watcher收集到dep中"},{"t":"list_item","d":5,"p":{"lines":[12,13],"index":2},"v":"2. setter：更新值时重新observe并触发dep.notify更新watcher渲染"}]},{"t":"heading","d":3,"p":{"lines":[14,15]},"v":"compiler","c":[{"t":"list_item","d":5,"p":{"lines":[16,17],"index":1},"v":"1. 解析模板，触发数据的getter产生数据监听"},{"t":"list_item","d":5,"p":{"lines":[17,18],"index":2},"v":"2. 一旦数据变动则会触发setter"}]},{"t":"heading","d":3,"p":{"lines":[19,20]},"v":"watcher","c":[{"t":"list_item","d":5,"p":{"lines":[22,23],"index":1},"v":"1. 数据getter时触发依赖Dep收集watcher"},{"t":"list_item","d":5,"p":{"lines":[23,24],"index":2},"v":"2. 自身存在update方法，用于触发页面更新"},{"t":"list_item","d":5,"p":{"lines":[24,25],"index":3},"v":"3. dep调用notify时会触发收集的所有watcher更新"}]}]},{"t":"heading","d":2,"p":{"lines":[26,27]},"v":"响应式数据处理","c":[{"t":"heading","d":3,"p":{"lines":[28,29]},"v":"响应式数据处理大致流程","c":[{"t":"list_item","d":5,"p":{"lines":[32,33],"index":1},"v":"1. vue实例创建，遍历data中的属性"},{"t":"list_item","d":5,"p":{"lines":[33,34],"index":2},"v":"2. Object.defineProperty更改data属性中的getter和setter"},{"t":"list_item","d":5,"p":{"lines":[34,35],"index":3},"v":"3. 内部追踪依赖关系，利用watcher进行处理，渲染的时候依赖会进行收集watcher"},{"t":"list_item","d":5,"p":{"lines":[35,36],"index":4},"v":"4. 后续依赖的setter被调用时，watcher会进行重新计算，组件进行更新"}]},{"t":"heading","d":3,"p":{"lines":[37,38]},"v":"data为什么是个函数","c":[{"t":"list_item","d":5,"p":{"lines":[39,40],"index":1},"v":"1. 组件每次创建时都需要有自己私有的数据空间"},{"t":"list_item","d":5,"p":{"lines":[40,41],"index":2},"v":"2. 直接返回对象则同一组件共用data"},{"t":"list_item","d":5,"p":{"lines":[41,42],"index":3},"v":"3. 用函数则是会在每次服用组件时返回一个新data，相同组件间的数据不会互相干扰"}]},{"t":"heading","d":3,"p":{"lines":[43,44]},"v":"data值变动会立即更新视图吗","c":[{"t":"list_item","d":5,"p":{"lines":[45,46],"index":1},"v":"1. 不会，vue的渲染是异步更新，减少重复运算"},{"t":"list_item","d":5,"p":{"lines":[46,47],"index":2},"v":"2. 数据变化vue会开启一个队列并缓冲同一事件循环中发生数据变更"},{"t":"list_item","d":5,"p":{"lines":[47,48],"index":3},"v":"3. 同一个watcher触发多次，但是只会向队列推入一次"}]},{"t":"heading","d":3,"p":{"lines":[49,50]},"v":"使用defineProperty处理缺陷","c":[{"t":"list_item","d":5,"p":{"lines":[51,52],"index":1},"v":"1. Object.defineProperty()对一些对象属性操作时，有一些方法无法拦截","c":[{"t":"list_item","d":7,"p":{"lines":[52,53],"index":1},"v":"1. 数组下标修改"},{"t":"list_item","d":7,"p":{"lines":[53,54],"index":2},"v":"2. delete操作删除"}]},{"t":"list_item","d":5,"p":{"lines":[54,55],"index":2},"v":"2. 对于这些问题Vue通过重写默认函数处理这个问题"},{"t":"list_item","d":5,"p":{"lines":[55,56],"index":3},"v":"3. 而在Vue3.0 中使用Proxy处理","c":[{"t":"list_item","d":7,"p":{"lines":[56,57],"index":1},"v":"1. Proxy能监听到任何数据改变"},{"t":"list_item","d":7,"p":{"lines":[57,58],"index":2},"v":"2. 缺点式兼容性不好"}]}]},{"t":"heading","d":3,"p":{"lines":[59,60]},"v":"数组响应式处理","c":[{"t":"fence","d":4,"v":"<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> methodsToPatch <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'push'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'pop'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'shift'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'unshift'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'splice'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'sort'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'reverse'</span>\n<span class=\"token punctuation\">]</span>\n</code></pre>\n"},{"t":"ordered_list","d":4,"p":{"lines":[78,81],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[78,79],"index":1},"v":"1. 对新增数组的方法的插入值进行响应式处理：ob.observeArray(inserted)"},{"t":"list_item","d":5,"p":{"lines":[79,80],"index":2},"v":"2. 通知dep进行渲染更新：ob.dep.notify()"}]}]},{"t":"heading","d":3,"p":{"lines":[81,82]},"v":"vue如何监听对象或者数组某个属性的变化","c":[{"t":"list_item","d":5,"p":{"lines":[87,88],"index":1},"v":"1. this.$set","c":[{"t":"list_item","d":7,"p":{"lines":[88,89],"index":1},"v":"1. 如果是数组，直接使用splice方法"},{"t":"list_item","d":7,"p":{"lines":[89,90],"index":2},"v":"2. 如果是对象，判断属性是否存在，对象是否响应式"},{"t":"list_item","d":7,"p":{"lines":[90,91],"index":3},"v":"3. 原理见（类构建/stateMixin）"}]},{"t":"list_item","d":5,"p":{"lines":[91,92],"index":2},"v":"2. 数组则使用处理过的七个方法修改"}]},{"t":"heading","d":3,"p":{"lines":[93,94]},"v":"delete和Vue.delete删除数组区别","c":[{"t":"list_item","d":5,"p":{"lines":[95,96],"index":1},"v":"1. delete只是被删除元素变成了undefined，其他元素的键值不变"},{"t":"list_item","d":5,"p":{"lines":[96,97],"index":2},"v":"2. Vue.delete 直接删除数组并改变了数组的键值"}]}]},{"t":"heading","d":2,"p":{"lines":[98,99]},"v":"依赖收集","c":[{"t":"ordered_list","d":3,"p":{"lines":[102,105],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[102,103],"index":1},"v":"1. initState初始化状态，defineReactive将对象变成响应式，并且getter则会进行依赖收集"},{"t":"list_item","d":4,"p":{"lines":[103,104],"index":2},"v":"2. mount时，实例化渲染wacther，并会将传入的updateComponent触发，触发里面vm._render()时则同时触发响应式数据的getter"}]},{"t":"heading","d":3,"p":{"lines":[105,106]},"v":"defineReactive","c":[{"t":"list_item","d":5,"p":{"lines":[107,108],"index":1},"v":"1. 实例化了一个Dep实例dep"},{"t":"list_item","d":5,"p":{"lines":[108,109],"index":2},"v":"2. get时触发dep.depend进行依赖收集"}]},{"t":"heading","d":3,"p":{"lines":[110,111]},"v":"Dep","c":[{"t":"list_item","d":5,"p":{"lines":[112,113],"index":1},"v":"1. 存在静态属性target暂存一个全局唯一的Watcher"},{"t":"list_item","d":5,"p":{"lines":[113,114],"index":2},"v":"2. subs是一个Watcher数组，针对watcher的收集"},{"t":"list_item","d":5,"p":{"lines":[114,115],"index":3},"v":"3. depend触发当前全局的Watcher的addDep"},{"t":"list_item","d":5,"p":{"lines":[115,116],"index":4},"v":"4. notify则是触发subs中所有的update"}]},{"t":"heading","d":3,"p":{"lines":[117,118]},"v":"Watcher","c":[{"t":"list_item","d":5,"p":{"lines":[119,120],"index":1},"v":"1. 渲染watcher的get会触发响应式对象的get"},{"t":"list_item","d":5,"p":{"lines":[120,121],"index":2},"v":"2. addDep触发传入dep的addSub收集当前watcher"}]}]},{"t":"heading","d":2,"p":{"lines":[122,123]},"v":"异步更新","c":[{"t":"heading","d":3,"p":{"lines":[126,127]},"v":"Computed和Watch的区别","c":[{"t":"heading","d":4,"p":{"lines":[128,129]},"v":"Computed","c":[{"t":"list_item","d":6,"p":{"lines":[130,131],"index":1},"v":"1. 支持缓存，只有数据值发生变化才重新计算，并且默认缓存"},{"t":"list_item","d":6,"p":{"lines":[131,132],"index":2},"v":"2. 参数为函数则默认为get，也可以是对象去主动实现get和set"},{"t":"list_item","d":6,"p":{"lines":[132,133],"index":3},"v":"3. 不支持异步"}]},{"t":"heading","d":4,"p":{"lines":[134,135]},"v":"Watch","c":[{"t":"list_item","d":6,"p":{"lines":[136,137],"index":1},"v":"1. 不支持缓存，数据变化就触发操作，即使值没变"},{"t":"list_item","d":6,"p":{"lines":[137,138],"index":2},"v":"2. 触发函数接收两个参数，最新的值和变化之前的值"},{"t":"list_item","d":6,"p":{"lines":[138,139],"index":3},"v":"3. 具有配置参数","c":[{"t":"list_item","d":8,"p":{"lines":[139,140],"index":1},"v":"1. deep：深度监听"},{"t":"list_item","d":8,"p":{"lines":[140,141],"index":2},"v":"2. immediate：组件加载立即触发"}]},{"t":"list_item","d":6,"p":{"lines":[141,142],"index":4},"v":"4. 支持异步"}]},{"t":"heading","d":4,"p":{"lines":[143,144]},"v":"使用时机","c":[{"t":"list_item","d":6,"p":{"lines":[145,146],"index":1},"v":"1. Computed需要数值计算时使用"},{"t":"list_item","d":6,"p":{"lines":[146,147],"index":2},"v":"2. Watch数据变化就需要执行，即使值未变"}]}]},{"t":"heading","d":3,"p":{"lines":[148,149]},"v":"Computed和Methods的区别","c":[{"t":"list_item","d":5,"p":{"lines":[150,151],"index":1},"v":"1. Computed会按照依赖进行缓存，只有值不同才触发"},{"t":"list_item","d":5,"p":{"lines":[151,152],"index":2},"v":"2. Methods则调用就执行"}]},{"t":"heading","d":3,"p":{"lines":[153,154]},"v":"$nextTick","c":[{"t":"ordered_list","d":4,"p":{"lines":[156,161],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[156,157],"index":1},"v":"1. Promise"},{"t":"list_item","d":5,"p":{"lines":[157,158],"index":2},"v":"2. MutationObserver"},{"t":"list_item","d":5,"p":{"lines":[158,159],"index":3},"v":"3. setImmediate"},{"t":"list_item","d":5,"p":{"lines":[159,160],"index":4},"v":"4. setTimeout"}]},{"t":"heading","d":4,"p":{"lines":[161,162]},"v":"使用异步更新的原因","c":[{"t":"list_item","d":6,"p":{"lines":[163,164],"index":1},"v":"1. 同步更新在多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染"},{"t":"list_item","d":6,"p":{"lines":[164,165],"index":2},"v":"2. 当具有VirtualDOM，每次变动就计算开销巨大"}]},{"t":"heading","d":4,"p":{"lines":[166,167]},"v":"使用nextTick的情况","c":[{"t":"list_item","d":6,"p":{"lines":[168,169],"index":1},"v":"1. 数据变化后执行的DOM操作"},{"t":"list_item","d":6,"p":{"lines":[169,170],"index":2},"v":"2. created()钩子进行DOM操作"}]}]}]}]})</script>
</body>
</html>
