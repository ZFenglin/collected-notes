# 模板编译

vue实例初始化结尾触发vm.$mount(vm.$options.el)，开始进行模板编译和元素挂载

模板编译从$mount开始

## Vue.prototype.$mount

处理元素的创建和挂载

由于这个方法和平台相关，vue将其放在了src\platforms文件夹下

同时Vue.prototype.$mount存在两个地方进行做了处理

### 各个平台公共的mount

位于src\platforms\web\runtime\index.js

公共的$mount方法，会在各个平台下重写

```JS
// 设置__patch__
Vue.prototype.__patch__ = inBrowser ? patch : noop

// 公共的mount方法
Vue.prototype.$mount = function(el, hydrating) {
    // 获取元素
    el = el && inBrowser ? query(el) : undefined
    // 组件挂载
    return mountComponent(this, el, hydrating)
}
```

### web平台独有的mount

位于src\platforms\web\entry-runtime-with-compiler.js

只处理web下的情形

1. 获取当前元素
2. render函数获取
   1. template模板获取
   2. 通过模板获取render
3. 执行公共mount

```JS
// 公共mount备份
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function(el, hydrating) {
    // 1. 获取当前元素
    el = el && query(el)
    // 对于body和documentElement直接返回
    if (el === document.body || el === document.documentElement) {
        return this
    }
    // 2. render函数获取
    const options = this.$options
    if (!options.render) {
        // 2.1 模板获取
        let template = options.template
        if (template) {
            if (typeof template === 'string') {
                if (template.charAt(0) === '#') {
                    template = idToTemplate(template)
                }
            } else if (template.nodeType) {
                template = template.innerHTML
            } else {
                return this
            }
        } else if (el) {
            template = getOuterHTML(el)
        }
        // 2.2 通过模板获取render
        if (template) {
            const {
                render,
                staticRenderFns
            } = compileToFunctions(template, {
                outputSourceRange: process.env.NODE_ENV !== 'production',
                shouldDecodeNewlines,
                shouldDecodeNewlinesForHref,
                delimiters: options.delimiters,
                comments: options.comments
            }, this)
            options.render = render
            options.staticRenderFns = staticRenderFns
        }
    }
    // 3. 执行公共mount
    return mount.call(this, el, hydrating)
}
```

从render函数获取可以知道，组件渲染配置优先级上render > template > el

## render函数获取

mount中compileToFunctions处理后获取render函数

compileToFunctions则是由compiler\index中的createCompiler传入参数获取的

而传入其中的baseCompile做了以下步骤

1. 解析template获取ast
2. 静态节点处理
3. ast转化为执行代码

```JS
export const createCompiler = createCompilerCreator(function baseCompile(template, options) {
    // 解析template获取ast
    const ast = parse(template.trim(), options)
    // 静态节点处理
    if (options.optimize !== false) {
        optimize(ast, options)
    }
    // ast转化为执行代码
    const code = generate(ast, options)
    return {
        ast,
        render: code.render,
        staticRenderFns: code.staticRenderFns

    }
})
```

### 解析template
