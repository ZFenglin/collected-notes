# 异步&事件循环

这个相关的问题推荐看以下笔记

1. [浏览器原理/进程和线程](../../浏览器原理/02-进程和线程.md)
2. [浏览器原理/事件循环](../../浏览器原理/04-事件循环.md)
3. [JavaScript/异步编程](../index.md)

## 01

```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    console.log(2);
});
promise.then(() => {
    console.log(3);
});
console.log(4);

/// 打印内容
// 1
// 2
// 4
```

由于promise内部并未调用resolve或reject，所以一直处于pending状态，从而then不会触发

## 02

```js
const promise1 = new Promise((resolve, reject) => {
    console.log('promise1') // 1
    resolve('resolve1')
})
const promise2 = promise1.then(res => {
    console.log(res) // 4
})
console.log('1', promise1); // 2
console.log('2', promise2); // 3

/// 打印内容
// promise1
// 1 Promise {<fulfilled>: 'resolve1'}
// 2 Promise {<pending>}
// resolve1
```

1. 第一遍同步执行1，2，3的console
   1. promise1为fulfilled，是因为已经resolve了
   2. promise2为pending，是因为then中没有返回值
2. 同步执行完成，处理微任务执行4的console

## 03

```js
Promise.resolve().then(() => {
    console.log('promise1');
    const timer2 = setTimeout(() => {
        console.log('timer2')
    }, 0)
});
const timer1 = setTimeout(() => {
    console.log('timer1')
    Promise.resolve().then(() => {
        console.log('promise2')
    })
}, 0)
console.log('start');

/// 打印内容
// start
// promise1
// timer1
// promise2
// timer2
```

1. 第一次事件循环
   1. promise1的then微任务注册
   2. timer1的宏任务注册
   3. 打印start
   4. 执行微任务
      1. 打印promise1
      2. 注册timer2的宏任务
2. 第二次事件循环（timer1宏任务）
   1. 打印timer1
   2. 注册promise2微任务
   3. 清空微任务
      1. 打印promise2
3. 第三次事件循环（timer2宏任务）
   1. 单元timer2

## 04

```js
const promise = new Promise((resolve, reject) => {
    resolve('success1');
    reject('error');
    resolve('success2');
});
promise.then((res) => {
    console.log('then:', res);
}).catch((err) => {
    console.log('catch:', err);
})

/// 打印内容
// then: success1
```

1. promise状态更新了就不会变动，所以该题只会触发success1的then

## 05

```js
Promise.resolve(1)
    .then(2)
    .then(Promise.resolve(3))
    .then(console.log)

/// 打印内容
// 1

// 此时的得到的Promise为Promise {<fulfilled>: undefined}
```

1. Promise.resolve的value为带有then方法的对象，则返回的promise状态由then决定，否则状态为fulfilled，返回值就是value
2. then的参数不为函数的话，则直接跳过，执行后面的then，即传入非函数则会发生值透传
3. then的函数执行，如果没有返回值，也按照fulfilled处理，并值为undefined

## 06

```js
Promise.resolve().then(() => {
    return new Error('error!!!')
}).then(res => {
    console.log("then: ", res)
}).catch(err => {
    console.log("catch: ", err)
})

/// 打印内容
// then:  Error: error!!!
```

1. 返回一个Error实例，并不是throw，不会触发catch

## 07

```js
const promise = Promise.resolve().then(() => {
    return promise;
})
promise.catch(console.err)

/// 打印内容
// Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>
```

1. promise的then或catch返回值不能为pormise本身，否则会死循环

## 08

```js
Promise.reject('err!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })

/// 打印内容
// error err!!!
```

1. then的参数有两个
    1. 用来处理Promise成功的函数
    2. 错误执行，当出现错误被捕获时，后续的catch是不会触发的

## 09

```js
Promise.resolve('1')
  .then(res => {
    console.log(res)
  })
  .finally(() => {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() => {
    console.log('finally2')
    return Promise.resolve('3')
  })
  .then(res => {
    console.log('finally2后面的then函数', res)
  })

/// 打印内容
// 1
// finally2
// finally
// finally2后面的then函数 2
```

1. 先注册先执行
2. finally的默认返回是上一个的Promise对象值，但是错误则是返回一个异常的Promise

## 10

```js
function runAsync (x) {
  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
       .then(res => console.log(res))
       .catch(err => console.log(err))

/// 打印内容
/// 1s后输出
// 1
// 3
/// 2s后输出
// 2
// Error: 2 // 这里出发了catch，导致后续的不会再触发promise的回调
/// 4s后输出
// 4
```
