# 代码质量

[代码质量-思维导图](./mind/04-代码质量.html)

## TreeSharking

依赖于静态的ES6的模块化，去除未使用代码

### webpack配置

#### 开启前提

1. mode: production
2. optimization.usedExports: true
3. optimization.minimize: true
4. production模式下，后两个条件自动为true

develpoment下js的tree shaking是不生效的

```js
const config = {
    mode: 'production',
    optimization: {
        usedExports: true,
        minimize: true
        // 或指定特定的minifier时
        // minimizer: [                
        // new TerserPlugin({...})
        //]
    }
};
```

### 副作用

1. 在做tree shaking时，webpack会移删除未import过或未使用的代码
2. 但有些代码虽然未import， 但可能内部定义了全局变量，或者它是全局CSS文件
3. 通过设置副作用保留这些文件

```json
// 所有代码有副作用
{
 "sideEffects": true
}
// 所有代码没有副作用
{
 "sideEffects": false
}
// 地址数组，指定特定有副作用的文件集合
{
 "sideEffects": [
  "./src/file1.js",
  "./src/file2.js"
 ]
}
```

### TreeSharking适配

1. Npm大部分的包默认都是CommonJS，不支持
2. 但是这些库提供ES6的代码，利用mainFields来配置使用ES6的方式

## Scope Hoisting

通过ES6语法静态分析，将模块尽可能的放到统一函数中，即多文件合并为一个文件

### 提升优势

1. 代码体积小
2. 作用域变少，内存开销减少

### Scope Hoisting设置方式

1. Webpack自带的ModuleConcatenationPlugin插件，配置即可
2. 但是由于只支持ES6模块化，mainFields设置优先使用ES6的依赖代码

```js
// webpack.config.js
module.exports = {
    optimization: {
        concatenateModules: true
    }
};
```

```js
resolve: {
    mainFields: ['jsnext:main', 'browser', 'main']
}
```

## Prepack

按照执行结果生成最简化代码，但是局限大，不适合线上环境
