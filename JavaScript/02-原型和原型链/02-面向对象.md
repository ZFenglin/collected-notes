# [面向对象](https://tsejx.github.io/javascript-guidebook/object-oriented-programming)
1. 理解面向对象，首先需要理解new这个操作符的原理，可以看this绑定部分，详见[JavaScript/作用域和闭包/this](../03-作用域和闭包/05-this.md)
2. 代码详见[JavaScript/手写代码/对象相关](../08-代码手写/01-对象相关.md)

## 创建对象

### 工厂模式

1. 创建对象的一种最常用的设计模式
2. 工厂模式不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂
3. 缺点是没有建立起对象和类型间的关系
4. React.createElement()、Vue.component() 都是工厂模式的实现

### 构造函数模式

1. 基本思想
   1. 函数内使用this增加属性
   2. 创建实例时使用new
2.  与工厂模式区别
    1. 没有显式地创建对象
    2. 直接将属性和方法赋给了 this 对象
    3. 没有 return 语句
    4. 虽然建立的联系，但是会有重复的实例方法的创建

### 原型模式

1. 基本思想
   1. 将实例的属性和方法都放在构造函数的prototype上
   2. 创建实例时使用new
2. 与构造函数模式区别
   1. 不会有重复属性创建
   2. 会造成新对象的这些属性和方法是由所有实例共享的
   3. 无法通过传参赋值

### 组合模式（首选）

1. 基本思想
   1. 实例属性在构造函数中使用this添加
   2. 实例方法放在构造函数的prototype中
   3. 创建实例时使用new
2. 特点
   1. 结合了构造函数和原型的优势，目前最流行的创建方式
   2. 支持参数初始化实例属性，兼顾了方法的复用性和属性的独立性
   3. 但是代码封装性不太好

### 动态原型模式

1. 动态原型模式将所有信息都封装在构造函数中
2. 而通过构造函数中初始化原型
3. 相比组合使用构造函数模式和原型模式，提升了封装性

### 寄生构造函数模式（不推荐）

1. 基本思想：对工厂模式使用new
2. 没有建立起对象和类型间的关系

### 稳妥构造函数模式（不推荐）

1. 基本思想：内部不使用this的工厂模式
2. 稳妥对象，指的是没有公共属性，而且其方法不引用 this 的对象
3. 稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序改动时使用
4. 没有建立起对象和类型间的关系

## 继承对象

### 原型链

1. 子类构造函数的prototype指向父类new出的实例上
2. 属性被所有的实例对象所共享
3. 创建子类实例的时候不能向父类构造函数传递参数

### 借用构造函数

1. 子类构造函数的内部使用call调用父类构造函数
2. 可以向父类传递参数
3. 父类原型属性和方法无法继承

### 组合继承

1. 将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式
2. 调用两次父类构造函数，造成属性重复
   1. 第一次是在创建子类型原型的时候
   2. 另一次是在子类型构造函数内部

### 原型式继承

1. 借助已有对象创建新对象
2. 将传入对象设置为一个函数的prototype，返回这个函数的的new结果
3. 返回的对象的`__proto__`为传入的对象
4. Object.create()原理，详见[JavaScript/代码手写/对象相关](../08-代码手写/01-对象相关.md)

### 寄生式继承

1. 利用原型式继承创建一个新对象对象
2. 在函数内部为新对象增加自定义属性

### 寄生组合式继承（首选）

1. 实现方式：采用了寄生式继承和借用构造函数方式组合处理
   1. 寄生式继承传入parent.prototype获取子类的prototype对象
   2. 子类的prototype.constructor指向children
   3. children的prototype更改
   4. children内部使用借用构造函数方式获取父类自生属性
2. 特点
   1. 保持了原型链的连接
   2. 没有重复的属性的创建，原型属性也能复用
