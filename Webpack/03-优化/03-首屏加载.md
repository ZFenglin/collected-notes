# 首屏加载

## 压缩代码

### 压缩JS

安装插件

```bash
npm install uglifyjs-webpack-plugin --save-dev
```

插件配置

```js
module.exports = {
    optimization: {
        minimizer: [new UglifyJsPlugin()],
    },
}
```

1. UglifyJsPlugin处理ES6代码会报错，所以专门分出一个用于处理ES6的分支UglifyESPlugin
2. ParallelUglifyPlugin则是将代码压缩设置为多进程处理

### 压缩CSS

安装插件

```bash
# cssnano css压缩规则，例如margin：0 20px 0 20px; ==> margin: 0 20px;
npm i cssnano -D
npm i optimize-css-assets-webpack-plugin -D
```

插件配置

```js
new OptimizeCSSAssetsPlugin({
    //引入入cssnano配置压缩选项
    cssProcessor: require("cssnano"),
    cssProcessorOptions: {
        discardComments: {
            removeAll: true
        }
    }
})
```

### 压缩HTML

生成html的插件html-webpack-plugin也支持压缩html，配置方式如下

```js
new htmlWebpackPlugin({
    title: "京东商城",
    template: "./index.html",
    filename: "index.html",
    minify: {
        // 压缩HTML文文件
        removeComments: true, // 移除HTML中的注释
        collapseWhitespace: true, // 删除空白符与换行符
        minifyCSS: true // 压缩内联CSS
    }
}),
```

## CDN加速

将一些资源放到CDN服务器中，当需要使用的时候直接将地址指向CDN服务器，减少编译耗时和加快页面加载速度

### 注意部分

CDN服务通常会为资源开启长时间缓存，造成HTML文件更新了但是不刷新
1. 针对HTML文件：HTML文件放在自己的服务器上，同时关闭自己服务器的缓存
2. 针对静态JavaScript等文件：开启CDN和缓存，放到CDN服务器上，同时文件名需要带上文件内容得出的hash值

### 并行加载处理

浏览器在同一时刻对同一域名的请求有数量限制，所有资源放在一个CDN服务器下，则会出现阻塞

处理方式是将不同的资源放到不同的CDN服务上，但是会出现增加域名解析问题，在head中增加预解析域名

```html
<link rel="dns-prefetch" href="//js.cdn.com">
```

### CDN处理方式

#### JS代码CDN处理

webpack配置

```js
//webpack.config.js
module.exports = {
    //...
    externals: {
        //jquery通过script引入入之后,全局中即有了了 jQuery 变量量
        'jquery': 'jQuery'
    }
}
```

此时编译将不会在编译相关文件，但是需要自己在html中手动引入

```html
<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
```

#### 静态资源CDN处理

1. 静态资源导入URL变成执行CDN服务的地址
2. 静态文件名称需要内容得出的hash值
3. 不同资源放在不同的CDN服务上

```js
// webpack.config.js
output: {
    // 指定存放资源文件的CDN地址
    publicPath: 'http://cdn.com/',
}
```

htm生成时，增加一个标签, 但是需要手动上传文件至cdn服务器下

```html
<script src="http://cdn.com/main.js"></script>
```

而CSS则是在其它地方设置
1. css-loader.publicPath设置被导入CSS资源地址
2. WebPlugin.stylePublicPath中设置CSS文件的地址

## 多入口分割

通过手动配置webpack多个为入口

```js
module.exports = {
    entry: {
        //配置多个入口文件打包成多个代码块
        index: path.resolve(root_path, 'index.js'),
        a: path.resolve(root_path, 'a.js')
    },
}
```

此时打包的结果会分成两个文件，但是有以下问题
1. 如果index.js也引入了lodash，那么lodash将会同时打包到两个js模块中
2. 不灵活，不能根据核心应用程序的逻辑来动态分割代码

plugins中增加多个HtmlWebpackPlugin的类用作html多入口，同时设置chunk指定引入js，否则会都引入

## 提取公共代码

SPA（单页面应用），打包完成时，只有一个bundle.js
1. 代码体积大，不利于下载
2. 未合理使用浏览器资源（最多支持5/7个资源同时加载）

MPA（多页面应用），多个页面使用了一个公共的模块则可以抽离处理，利与页面缓存

### 提取公共代码好处

1. 减少网络流量
2. 提升后续其它页面的加载速度

### 抽离原则

1. 网站使用的技术栈基本代码，如react，vue，存放在base.js
2. 所有页面共有代码，存放在common.js中

### webpack配置

SplitChunksPlugin，webpack自带，配置optimization.splitChunks就可以开启

```js
optimization: {
    splitChunks: {
        chunks: 'async', // 同步 initial，异步 async，所有的模块 all
        minSize: 30000, //最小尺寸，当模块大于30kb时会进行分割
        maxSize: 0, // 对模块二次分割，但是不推荐（易出错）
        minChunks: 1, // chunk模块最少引用了几次，超过次数分割出来
        maxAsyncRequests: 5, // 最大异步请求数,默认5
        maxInitialRequests: 3, // 最大初始化请求数,入口文件同步请求,默认3
        automaticNameDelimiter: '-', // 打包分割符号
        name: true, // 打包后的名称,除了了布尔值,还可以接收一个函数function
        //缓存组 用于手动分割打包文件
        // 上文的配置缓存组都可以使用，只是多出了一个priority定义
        cacheGroups: {
            vendors: {
                test: /[\\/]node_modules[\\/]/,
                name: "vendor", // 要缓存的 分隔出来的 chunk 名称
                priority: -10 // 缓存组优先级 数字越大，优先级越高，缓存组中优先处理
            },
            lodash: {
                test: /lodash/,
                name: "lodash",
            },
            react: {
                test: /react|react-dom/,
                name: "react",
            },
            other: {
                chunks: "initial", // 必须三选一: "initial" | "all" | "async"(默认就是async)
                test: /react|lodash/, // 正则规则验证,如果符合就提取 chunk,
                name: "other",
                minSize: 30000,
                minChunks: 1,
            },
            default: {
                minChunks: 2,
                priority: -20,
                reuseExistingChunk: true //可设置是否重用该chunk
            }
        }
    }
},
```

## 动态导入

网站按照功能分出类别，每个类别对应一个Chunk，分割出去的代码在特定时机触发加载

### 实现动态导入

代码使用时增加/* webpackChunkName: "show" */表示当前为动态导入

```js
import( /* webpackChunkName: "show" */ './show').then((show) => show())
```

webpack在遇到/* webpackChunkName: "show" */会进行以下处理
1. 以./show.js重新创建一个Chunk
2. 当代码执行到import才会加载文件
3. import返回一个Promise，then后才能执行

同时指定output设置对应文件输出文件名称

```js
module.exports = {
    output: {
        chunkFilename: '[name].demand.js',
    },
}
```

### 预取和预加载模块

#### prefetch

在浏览器空闲的时候加载未来可能会用到的资源

```js
import( /* webpackPrefetch: true */ './path/to/LoginModal.js')
```

html设置标签并追加到页面头部，指示着浏览器在闲置时间预取对应文件

```html
<link rel="prefetch" href="login-modal-chunk.js">
```

#### preload

先加载本页面需要用到的关键资源，不会等待浏览器空闲

```js
import( /* webpackPreload: true */ 'ChartingLibrary');
```

## 图片处理

1. 压缩图片：imagemin-webpack-plugin
2. 小图片base64编码：url-loader

### 压缩图片

插件安装

```bash
npm install imagemin-webpack-plugin
```

插件配置

```js
new ImageminPlugin({
    plugins: [
        imageminMozjpeg({
            quality: 100,
            progressive: true
        })
    ]
})
```

### 小图片base64编码

相比file-loader, 可以增加limit

```js
rules: [{
    // ?表示前一个可有可无
    test: /\.(png|jpe?g|gif)$/,
    use: {
        loader: "url-loader",
        options: {
            // ext 后缀名
            name: "[name]_[hash:6].[ext]",
            outputPath: "images/",
            // 将图片文件转化为base64，推荐小文件使用，大体积文件不推荐
            limit: 2 * 1024 // 单位是字节 1024=1kb
        }
    }
}]
```

## 抽离CSS

单独生成css, css可以和js并行下载, 提高页面加载效率

```bash
npm install mini-css-extract-plugin -D
```

webpack配置

```js
rules: [{
    test: /\.scss$/,
    use: [
        // "style-loader", 
        // 不不再需要style-loader, 用MiniCssExtractPlugin.loader代替
        MiniCssExtractPlugin.loader,
        "css-loader", // 编译css
        "postcss-loader",
        "sass-loader" // 编译scss
    ]
}]
plugins: [
    new MiniCssExtractPlugin({
        filename: "css/[name]_[contenthash:6].css",
        chunkFilename: "[id].css"
    })
]
```
