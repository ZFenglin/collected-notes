# 闭包

闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包

函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行

```JS
function foo() {
    var a = 2;

    function bar() {
        console.log(a);
    }
    return bar;
}
```

## 特点

1. 函数可以访问另一个函数的作用域下的变量
2. 局部变量会常驻在内存中，可能会造成内存泄漏
3. 可以用于避免使用全局变量，防止污染，如Jquery

## 作用

### 处理循环问题（let可以处理）

当let和const出现之前，循环体中由于var的提升，i将会不会按照循环触发的方式打印结果

```JS
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
```

此时可以利用闭包解决

```JS
for (var i = 1; i <= 5; i++) {
    (function(j) {
        setTimeout(function timer() {
            console.log(j);
        }, j * 1000);
    })(i);
}
```

### 模块化

闭包对于模块化的使用，具备以下两个条件

1. 必须有外部的封闭函数，该函数必须至少被调用一次
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包

```JS
var foo = (function CoolModule(id) {
    function change() {
        // 修改公共 API
        publicAPI.identify = identify2;
    }

    function identify1() {
        console.log(id);
    }

    function identify2() {
        console.log(id.toUpperCase());
    }
    var publicAPI = {
        change: change,
        identify: identify1
    };
    return publicAPI;
})("foo module");
foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODUL
```

### 柯里化

柯里化可以让函数存在多个参数时可以先传递一部分参数调用它，并返回一个新函数接收剩余参数并执行，直到接收完所有参数后返回结果

lodash的_.curry(func)就是一个柯里化工具函数

柯里化具有以下特点
1. 函数参数的缓存
2. 函数更灵活，细粒度更小
3. 多元函数变成一元函数

```JS
function curry(fn, args) {
    // 获取函数需要的参数长度
    let length = fn.length;
    args = args || [];
    return function() {
        let subArgs = args.slice(0);
        // 拼接得到现有的所有参数
        for (let i = 0; i < arguments.length; i++) {
            subArgs.push(arguments[i]);
        }
        // 判断参数的长度是否已经满足函数所需参数的长度
        if (subArgs.length >= length) {
            // 如果满足，执行函数
            return fn.apply(this, subArgs);
        } else {
            // 如果不满足，递归返回科里化的函数，等待参数的传入
            return curry.call(this, fn, subArgs);
        }
    };
}
// ES6简化调用
function curry(fn, ...args) {
    return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);
}
```

### 防抖和节流

函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时

这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求

```JS
// 函数防抖的实现
function debounce(fn, wait) {
    let timer = null;
    return function() {
        let context = this,
            args = arguments;
        // 如果此时存在定时器的话，则取消之前的定时器重新记时
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
        // 设置定时器，使事件间隔指定事件后执行
        timer = setTimeout(() => {
            fn.apply(context, args);
        }, wait);
    };
}
```

函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效

节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率

```JS
// 函数节流的实现;
function throttle(fn, delay) {
    let curTime = Date.now();
    return function() {
        let context = this,
            args = arguments,
            nowTime = Date.now();
        // 如果两次时间间隔超过了指定时间，则执行函数。
        if (nowTime - curTime >= delay) {
            curTime = Date.now();
            return fn.apply(context, args);
        }
    };
}
```
