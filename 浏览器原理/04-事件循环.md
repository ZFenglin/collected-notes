# 事件循环

## JS执行方式

### 单线程

1. JS单线程运行，同一时间只能做一件事
2. 可以使用工作者线程开辟新线程

### JS代码执行顺序

1. 从上往下
2. 同步执行
3. 异步放入处理线程，处理线程触发后将事件放入队列等待执行
4. 出错停止执行

## 宏任务和微任务

### 宏任务（Macrotask）

宏任务是浏览器规定，一般浏览器都会有对应线程处理这些任务

#### 宏任务种类

##### 主线程代码

JS引擎线程处理

##### DOM事件

事件触发线程处理

##### 定时器

定时器触发线程处理

1. setTimeout
2. setInterval
3. setImmediate

##### 异步HTTP请求

异步http请求线程处理

1. ajax
2. I/O流（文件上传下载）

### 微任务（Microtask）

微任务是ES6规定，回调事件放入到Micro Task Queue中，不放在Web APIs中是因为他是ES规范

#### 微任务作用

减少UI渲染次数，每次宏任务执行前都会清空之前的微任务并渲染页面

#### 微任务种类

##### 期约

1. Promise回调
2. async/await中await后方代码

##### MutationObserver

监视对DOM树所做更改，html5新增

##### process.nextTick

Node的微任务处理

## 浏览器事件循环

### 浏览器事件循环的结构

#### 执行栈（Call Stack）

存储函数调用的栈结构
1. 遵循先进后出
2. 可存放函数有限制，过多的函数会造成爆栈

执行栈的执行过程
1. 执行代码时遇见函数则入栈，同步代码直接执行，异步事件放入对应线程处理
2. 当函数执行完成后出栈

#### 浏览器定义的APIs（Web APIs）

对应线程中处理宏任务的异步事件

#### 事件队列（Task Queue）

接收Web APIs回调

事件队列执行方式
1. 一次只执行一个事件
2. 当有新事件加入时并不会立即执行

注意！！！鼠标点击元素和调用click方法触法时不同的
1. clik触发多个点击事件是所有宏任务处理完再处理微任务
2. 执行栈中clik一直在，所以微任务不执行

#### 微任务队列（Microtask Queue）

接收微任务回调，只要执行栈一空就会清空微任务

微任务队列执行方式
1. 一直执行，直到队列清空
2. 当执行过程中有新事件加入时，也会直接执行
3. 由于微任务处理是同步的，过多的任务会阻塞渲染   

#### 渲染队列（Animation callback）

RAF回调处理

渲染队列执行方式
1. 一直执行，直到当前帧队列清空
2. 当有新事件加入时，只会将当前帧的处理完，执行过程中新加入的下次帧时执行

在计算css时不会看过程，只会看开始和最终的结果，可以在动画过程中增加getComputedStyle方法强制样式计算

##### [requestAnimationFrame是一个宏任务么](https://ginobilee.github.io/blog/2019/02/01/requestAnimationFrame%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B9%88/)

宏任务与raf任务有明显的差异:
1. 执行时机不同
2. raf任务队列被执行时，会将其此刻队列中所有任务都执行完
3. 
所以raf任务不属于宏任务，而由于微任务的特殊性(单独的任务队列)，它显然更不是微任务

### 浏览器事件循环的执行顺序

![浏览器事件循环](assets/04-浏览器事件循环.png)

1. 执行栈为空（当前宏任务结束）
2. 清空微任务队列，将微任务队列中的事件放至执行栈执行
3. 页面UI渲染
4. 触发Event Loop，将事件队列中事件回调放入执行栈中执行
5. 执行代码，清空执行栈，开启下次循环

## [Node事件循环](https://juejin.cn/post/6844903999506923528#heading-5)

![node循环](assets/04-node循环.png)

### Node循环阶段

Node循环阶段中的microtask 来说，它会在以下每个阶段完成前清空 microtask 队列

#### Timers（定时器阶段）

执行 setTimeout(callback) 和 setInterval(callback) 预定的 callback

#### I/O callbacks（I/O回调阶段)

执行某些系统操作的回调

#### idle, prepare 阶段

node内部使用

#### poll（轮询阶段）

##### 回调队列不为空

执行回调，每个回调执行完，立即执行它的微任务

##### 回调队列为空

存在setImmediate()未执行，则结束轮询进入Check

否则会阻塞并等待任何正在执行的I/O操作完成，马上执行相应的回调，直到所有回调执行完毕

#### Check（查询阶段）

setImmediate() 设定的callbacks，回调中触发微任务，则将微任务执行完

#### Close callbacks

执行一些回调的关闭

### process.nextTick

1. 独立于 Event Loop 之外的，拥有一个自己的队列
2. 每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数
3. 优先于microtask执行
