# 排序算法

## 基础概念

### 大O表示法

1. 粗略的度量算法效率
2. 不同数据规模，算法的效率会发生变化

![大O表示形式](./assets/大O表示形式.jpg)

### ArrayList类

```js
function ArrayList() { this.array = [] }
ArrayList.prototype.insert = function (item) { return this.array.push(item) }
ArrayList.prototype.toString = function () { return this.array.join(',') }
ArrayList.prototype.compare = function (m, n) { return this.array[m] > this.array[n] }
ArrayList.prototype.swap = function (m, n) {
    var temp = this.array[m]
    this.array[m] = this.array[n]
    this.array[n] = temp
}
// 之后再上面添加对应排序算法
```

## 简单排序

### 冒泡排序

#### 冒泡排序实现

1. 从头到尾依次比较相邻元素大小，左边大则和右边互换
2. 第一遍后则最大的就在最后，然后重复遍历（最后一个无需处理）

```js
ArrayList.prototype.bubbleSort = function () {
    // 最后一位无法处理，因为无法和下一位进行比较
    let j = this.array.length - 1
    while (j) {
        for (let i = 0; i < j; i++) {
            //  比较相邻元素大小，左大右小则交换数据
            if (this.compare(i, i + 1)) {
                this.swap(i, i + 1)
            }
        }
        j--
    }
}
```

#### 冒泡排序效率

1. 比较次数：O(N^2)
2. 交换次数：O(N^2)

### 选择排序

#### 选择排序实现

1. 选出右边无序中最小的，并放到无序的第一个
2. 重复执行吗，直到整个列表变得有序

```js
ArrayList.prototype.selectionSort = function () {
    let length = this.array.length
    let j = 0
    while (j < length - 1) {
        let min = j
        // 遍历剩余寻找最小
        for (let i = min + 1; i < length; i++) {
            if (this.compare(min, i)) {
                min = i
            }
        }
        // 交换无序开头和最小
        this.swap(min, j)
        j++
    }
}
```

#### 选择排序效率

1. 比较次数：O(N^2)
2. 交换次数：O(N)
3. 优先于冒泡

### 插入排序

## 高级排序

### 希尔排序

### 归并排序

### 快速排序（推荐）

### 堆排序
