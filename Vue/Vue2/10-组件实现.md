# 组件实现

Vue组件的实现可以从Vue.component的实现入手

## Vue.component的实现

Vue.component的实现从08-GlobalAPI中能看出，initAssetRegisters中在Vue上注册了component

```JS
// ...
if (type === 'component' && isPlainObject(definition)) {
    definition.name = definition.name || id
    // 调用Vue.extend注册对应组件的构造函数
    definition = this.options._base.extend(definition)
}
// ...
this.options[type + 's'][id] = definition
```

从中可以看住使用了Vue.extend注册了Vue的组件的构造函数，并设置到options.component

### Vue.extend原理

Vue通过注册GlobalAPI时使用initExtend设置Vue.extend

01. Super相关属性获取
02. 检查是否是已经缓存的组件构造，存在直接返回
03. Sub创建，执行时调用内部的_init方法
04. Sub继承Super处理
05. Sub配置和其他属性处理
06. props代理和computed属性设置
07. Sub获取Super静态属性并设置
   1. extend、mixin、use
   2. ASSET_TYPES属性（component、directive、filter）
08. 自循环调用处理
09. Sub中的Super相关配置设置
10. 当前构造缓存
   

```JS
export function initExtend(Vue) {
    // 用作标记判断后续缓存获取
    Vue.cid = 0
    let cid = 1
    Vue.extend = function(extendOptions) {
        extendOptions = extendOptions || {}
        // 1. Super相关属性获取
        const Super = this
        const SuperId = Super.cid
        // 2. 检查是否是已经缓存的组件构造，存在直接返回
        const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
        if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId]
        }
        const name = extendOptions.name || Super.options.name
        // 3. Sub创建，执行时调用内部的_init方法
        const Sub = function VueComponent(options) {
            this._init(options)
        }
        // 4. Sub继承Super处理
        Sub.prototype = Object.create(Super.prototype)
        Sub.prototype.constructor = Sub
        // 5. Sub配置和其他属性处理
        Sub.cid = cid++
        Sub.options = mergeOptions(
            Super.options,
            extendOptions
        )
        Sub['super'] = Super
        // 6. props代理和computed属性设置
        if (Sub.options.props) {
            initProps(Sub)
        }
        if (Sub.options.computed) {
            initComputed(Sub)
        }
        // 7. Sub获取Super静态属性并设置
        Sub.extend = Super.extend
        Sub.mixin = Super.mixin
        Sub.use = Super.use
        ASSET_TYPES.forEach(function(type) {
            Sub[type] = Super[type]
        })
        // 8. 自循环调用处理
        if (name) {
            Sub.options.components[name] = Sub /// 子组件再自己的模板中使用自己
        }
        // 9. Sub中的Super相关配置设置
        Sub.superOptions = Super.options
        Sub.extendOptions = extendOptions
        Sub.sealedOptions = extend({}, Sub.options)
        // 10. 当前构造缓存
        cachedCtors[SuperId] = Sub
        return Sub
    }
}
```

#### component的配置合并

component在Vue中属于Assets，所以采用Assets的策略进行合并

```JS
function mergeAssets(
    parentVal,
    childVal,
    vm,
    key
) {
    // parentVal设置为res.prototype
    const res = Object.create(parentVal || null)
    if (childVal) {
        // extend只是将childVal上的值复制到res上
        return extend(res, childVal)
    } else {
        return res
    }
}

ASSET_TYPES.forEach(function(type) {
    strats[type + 's'] = mergeAssets
})
```

## 组件vnode获取

initRender时往实例上增加_c用于render调用vnode的生成，对应的函数为createElement

```JS
export function createElement(
    // ...
) {
    // ...
    return _createElement(context, tag, data, children, normalizationType)
}

export function _createElement(
    context,
    tag,
    data,
    children,
    normalizationType
) {
    // ...
    let vnode, ns
    if (typeof tag === 'string') {
        // tag为标签的情况
        // ...
        if (config.isReservedTag(tag)) {
            // 基本元素标签处理
            // ...
        } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
            // 组件标签处理
            vnode = createComponent(Ctor, data, context, children, tag)
        } else {
            // 剩余情况处理
            // ...
        }
    } else {
        // tag为构造函数的情况
        vnode = createComponent(tag, data, context, children)
    }
    //...
}
```

_createElement中对组件触发createComponent获取组件的vnode
01. Ctor获取和Ctor异常拦截
02. 异步组件按照异步组件处理并返回
03. 处理constructor的options
04. v-model转化为props和events
05. 额外的props处理
06. 函数式组件处理
07. 组件监听事件和原生事件处理
08. 抽象组件相关处理
09. 添加hook，用于后续组件init
10. 组件的vnode创建

```JS
export function createComponent(
    Ctor,
    data,
    context,
    children,
    tag
) {
    // 1. Ctor获取和Ctor异常拦截
    if (isUndef(Ctor)) {
        return
    }
    const baseCtor = context.$options._base
    if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor)
    }
    if (typeof Ctor !== 'function') {
        return
    }
    // 2. 异步组件按照异步组件处理并返回
    let asyncFactory
    if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
        if (Ctor === undefined) {
            return createAsyncPlaceholder(
                asyncFactory,
                data,
                context,
                children,
                tag
            )
        }
    }
    data = data || {}
    // 3. 处理constructor的options
    resolveConstructorOptions(Ctor)
    // 4. v-model转化为props和events
    if (isDef(data.model)) {
        transformModel(Ctor.options, data)
    }
    // 5. 额外的props处理
    const propsData = extractPropsFromVNodeData(data, Ctor, tag)
    // 6. 函数式组件处理
    if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children)
    }
    // 7. 组件监听事件和原生事件处理
    const listeners = data.on
    data.on = data.nativeOn
    // 8. 抽象组件相关处理
    if (isTrue(Ctor.options.abstract)) {
        const slot = data.slot
        data = {}
        if (slot) {
            data.slot = slot
        }
    }
    // 9. 添加hook，用于后续组件init
    installComponentHooks(data)
    // 10. 组件的vnode创建
    const name = Ctor.options.name || tag
    const vnode = new VNode( /// 创建虚拟节点 componentOptions 
        `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
        data, undefined, undefined, undefined, context, {
            Ctor,
            propsData,
            listeners,
            tag,
            children
        }, /// 包含组件的属性和事件 插槽作为children放在componentOptions上
        asyncFactory
    )
    return vnode
}
```

installComponentHooks用于处理为组件构造函数增加init钩子

```JS
function installComponentHooks(data) {
    const hooks = data.hook || (data.hook = {})
    for (let i = 0; i < hooksToMerge.length; i++) {
        const key = hooksToMerge[i]
        const existing = hooks[key]
        const toMerge = componentVNodeHooks[key]
        if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
        }
    }
}

function mergeHook(f1: any, f2: any): Function {
    const merged = (a, b) => {
        f1(a, b)
        f2(a, b)
    }
    merged._merged = true
    return merged
}
```

上述代码就是将componentVNodeHooks的钩子设置到组件的data.hook上

这里只详细介绍init的钩子处理

```JS
const componentVNodeHooks = {
    init(vnode, hydrating) {
        if (
            vnode.componentInstance &&
            !vnode.componentInstance._isDestroyed &&
            vnode.data.keepAlive // 有keepAlive标签，说明这个组件已经有了
        ) {
            // 组件已经存在，则patch组件，执行prepatch
            const mountedNode: any = vnode // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode)
        } else {
            // 根据组件实例创建vnode
            const child = vnode.componentInstance = createComponentInstanceForVnode(
                vnode,
                activeInstance // 当前激活的实例传入
            )
            // 组件挂载
            child.$mount(hydrating ? vnode.elm : undefined, hydrating)
        }
    },
    // 组件更新钩子
    prepatch(oldVnode, vnode) {},
    // 组件插入钩子
    insert(vnode) {},
    // 组件销毁钩子
    destroy(vnode) {}
}

export function createComponentInstanceForVnode(
    vnode,
    parent
) {
    // 处理相关配置
    // ...
    // 执行Ctor返回对应实例
    return new vnode.componentOptions.Ctor(options)
}
```

## 组件挂载处理

组件挂载则是在patch中处理，patch会调用createElm方法进行组件的创建

```JS
function createElm(
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
) {
    // ...
    // 检测时否是组件，如果是组件测创建组件
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return
    }
    // ...
}

function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    // 获取i
    let i = vnode.data
    if (isDef(i)) {
        const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
        // i.hook或者i.init存在，则执行创建组件
        if (isDef(i = i.hook) && isDef(i = i.init)) {
            i(vnode, false /* hydrating */ )
        }
        // 判断vnode.componentInstance是否存在得出组件是否成功创建
        if (isDef(vnode.componentInstance)) {
            initComponent(vnode, insertedVnodeQueue)
            insert(parentElm, vnode.elm, refElm)
            if (isTrue(isReactivated)) {
                reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
            }
            return true
        }
    }
}
```
