# [面向对象](https://tsejx.github.io/javascript-guidebook/object-oriented-programming)

理解面向对象，首先需要理解new这个操作符的原理

## new原理

1. 首先创建了一个新的空对象
2. 设置原型，将对象的原型设置为函数的 prototype 对象
3. 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

```JS
function _new(fn, args) {
    if (typeof fn !== 'function') {
        throw TypeError('fn is not function')
    }
    let obj = new Object()
    obj.__proto__ = fn.prototype
    let res = fn.apply(obj, args)
    return typeof res == 'object' ? res : obj
}
```

## 创建对象

### 工厂模式

创建对象的一种最常用的设计模式

工厂模式不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂

例如 React.createElement()、Vue.component() 都是工厂模式的实现

```JS
function createPerson(name, age, job) {
    let person = new Object();
    person.name = name;
    person.age = age;
    person.job = job;
    person.sayNam = function() {
        console.log(`I'm ${name}`);
    };
    return person;

}
const person2 = createPerson('Gray', 25, 'Doctor');
```

缺点是没有建立起对象和类型间的关系

### 构造函数模式

```JS
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        console.log(this.name);
    }
}
const person2 = new Person('Gray', 25, 'Doctor');
```

与工厂模式区别
1. 没有显式地创建对象
2. 直接将属性和方法赋给了 this 对象
3. 没有 return 语句

虽然建立的联系，但是会有重复的实例方法的创建

### 原型模式

将实例的属性和方法都放在构造函数的prototype上，利用new操作符创建对象

```JS
function Person() {}
Person.prototype.name = 'Uzi';
Person.prototype.age = 22;
Person.prototype.job = 'E-Sports Player';
Person.prototype.sayName = function() {
    console.log(this.name);
}
const uzi1 = new Person();
```

虽然比构造函数模式不会有重复属性创建，但是也会造成新对象的这些属性和方法是由所有实例共享的，并且无法通过传参赋值

### 组合使用构造函数模式和原型模式（首选）

结合了双方的优势，目前最流行的创建方式

```JS
// 构造函数
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ['Amy', 'Ben'];
}

// 原型模式
Person.prototype = {
    constructor: Person,
    sayName: function() {
        console.log(this.name);
    }
}
const uzi = new Person('Uzi', 22, 'Software Engineer');
```

支持参数初始化实例属性，兼顾了方法的复用性和属性的独立性，但是代码封装性不太好

### 动态原型模式

动态原型模式将所有信息都封装在构造函数中，而通过构造函数中初始化原型

```JS
function Person(name, age, job) {
    // 属性
    this.name = name;
    this.age = age;
    this.job = job;
    // 方法（动态插入原型方法）
    if (typeof this.sayName != 'function') {
        Person.prototype.sayName = function() {
            console.log(`I'm ${this.name}`);
        }
    }
}
const uzi = new Person('Uzi', 2, 'E-Sports Player');
```

相比组合使用构造函数模式和原型模式，提升了封装性

### 寄生构造函数模式（不推荐）

基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象

没有建立起对象和类型间的关系

```JS
function Person(name, age, job) {
    let obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.job = job;
    obj.sayName = function() {
        console.log(`I'm ${this.name}`);
    };
    return obj;
}
let uzi = new Person('Uzi', 22, 'E-Sports Player');
```

### 稳妥构造函数模式（不推荐）

稳妥对象，指的是没有公共属性，而且其方法不引用 this 的对象

稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序改动时使用

没有建立起对象和类型间的关系

```JS
function Person(name, age, job) {
    // 创建要返回的对象
    const obj = new Object();
    // 可以在这里定义私有变量和函数
    // 添加方法
    obj.sayName = function() {
        console.log(name);
    };
    // 返回对象
    return obj;
}
let uzi = Person('Uzi', 22, 'E-Sports Player');
```

## 继承对象

### 原型链

将子类对象的prototype指向父类new出的实例上

```JS
function Parent() {
    this.attr = {
        eye: 'blue',
        hair: 'black',
        skin: 'white',
    };
    this.sayName = function() {
        console.log('Name');
    };
}

function Child() {
    this.sayHi = function() {
        console.log('Hello world!');
    };
}

Child.prototype = new Parent()
```

在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱

还有就是在创建子类型的时候不能向超类型传递参数

### 借用构造函数

在子类型构造函数的内部调用父类构造函数以实现对父类构造函数属性的继承

```JS
function Parent(name) {
    this.name = name;
}

function Child() {
    //继承了 Parent，同时还传递了参数
    Parent.call(this, 'Uzi');
    //实例属性
    this.age = 18;
}
```

可以在子类型构造函数中向父类型构造函数传递参数

1. 只能继承父类实例对象的属性和方法，不能继承原型对象的属性和方法
2. 无法实现复用，每个子类都有父类实例函数的副本，影响性能

### 组合继承

将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式

```JS
function Parent(name) {
    this.name = name;
    this.attr = {
        eye: 'blue',
        hair: 'black',
        skin: 'white',
    };
}

Parent.prototype.sayName = function() {
    console.log(this.name);
};

function Child(name, age) {
    Parent.call(this, name);
    this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child; // constructor指向问题
Child.prototype.sayAge = function() {
    console.log(this.age);
};
```

都会调用两次父类构造函数：第一次是在创建子类型原型的时候，另一次是在子类型构造函数内部，造成属性重复

### 原型式继承（Object.create()原理）

```JS
function Person(friendship) {
    function Creator() {}
    Creator.prototype = friendship;
    return new Creator();
}
```

引用类型值的属性始终都会共享相应的值，多个实例对象对引用类型的操作会被篡改

### 寄生式继承

创建一个原型式继承的对象，并在函数内部以某种方式增强对象

```JS
function creator(origin) {
    let clone = Object.create(origin);
    clone.sayHi = function() {
        console.log('Hello world!');
    };
    return clone;
}
```

只适用于对象，而不是自定义类型和构造函数的情况下

### 寄生组合式继承（首选）

```JS
// 原型对象继承
function inherit(children, parent) {
    // 创建对象
    let prototype = Object.create(parent.prototype);
    // 增强对象
    prototype.constructor = children;
    // 指定对象
    children.prototype = prototype;
}

function Parent(name) {
    this.name = name;
    this.num = [0, 1, 2];
}

Parent.prototype.sayName = function() {
    alert(this.name);
};

function Child(name, age) {
    // 父类自身属性继承
    Parent.call(this, name);
    this.age = age;
}

inherit(Child, Parent);
```

只调用了一次 Parent 构造函数，并且因此避免了在 Child.prototype 上面创建不必要的、多余的属性。与此同时，原型链还保持不变
