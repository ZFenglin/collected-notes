<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"事件循环","c":[{"t":"heading","d":2,"p":{"lines":[2,3]},"v":"JS执行方式","c":[{"t":"heading","d":3,"p":{"lines":[4,5]},"v":"单线程","c":[{"t":"list_item","d":5,"p":{"lines":[6,7],"index":1},"v":"1. JS单线程运行，同一时间只能做一件事"},{"t":"list_item","d":5,"p":{"lines":[7,8],"index":2},"v":"2. 可以使用工作者线程开辟新线程"}]},{"t":"heading","d":3,"p":{"lines":[9,10]},"v":"JS代码执行顺序","c":[{"t":"list_item","d":5,"p":{"lines":[11,12],"index":1},"v":"1. 从上往下"},{"t":"list_item","d":5,"p":{"lines":[12,13],"index":2},"v":"2. 同步执行"},{"t":"list_item","d":5,"p":{"lines":[13,14],"index":3},"v":"3. 异步放入处理线程，处理线程触发后将事件放入队列等待执行"},{"t":"list_item","d":5,"p":{"lines":[14,15],"index":4},"v":"4. 出错停止执行"}]}]},{"t":"heading","d":2,"p":{"lines":[16,17]},"v":"宏任务和微任务","c":[{"t":"heading","d":3,"p":{"lines":[18,19]},"v":"宏任务（Macrotask）","c":[{"t":"heading","d":4,"p":{"lines":[22,23]},"v":"宏任务种类","c":[{"t":"heading","d":5,"p":{"lines":[24,25]},"v":"主线程代码"},{"t":"heading","d":5,"p":{"lines":[28,29]},"v":"DOM事件"},{"t":"heading","d":5,"p":{"lines":[32,33]},"v":"定时器","c":[{"t":"list_item","d":7,"p":{"lines":[36,37],"index":1},"v":"1. setTimeout"},{"t":"list_item","d":7,"p":{"lines":[37,38],"index":2},"v":"2. setInterval"},{"t":"list_item","d":7,"p":{"lines":[38,39],"index":3},"v":"3. setImmediate"}]},{"t":"heading","d":5,"p":{"lines":[40,41]},"v":"异步HTTP请求","c":[{"t":"list_item","d":7,"p":{"lines":[44,45],"index":1},"v":"1. ajax"},{"t":"list_item","d":7,"p":{"lines":[45,46],"index":2},"v":"2. I/O流（文件上传下载）（Node）"}]}]}]},{"t":"heading","d":3,"p":{"lines":[47,48]},"v":"微任务（Microtask）","c":[{"t":"heading","d":4,"p":{"lines":[51,52]},"v":"微任务作用","c":[{"t":"list_item","d":6,"p":{"lines":[53,54],"index":1},"v":"1. 减少UI渲染次数，每次宏任务执行前都会清空之前的微任务并渲染页面"}]},{"t":"heading","d":4,"p":{"lines":[55,56]},"v":"微任务种类","c":[{"t":"heading","d":5,"p":{"lines":[57,58]},"v":"期约","c":[{"t":"list_item","d":7,"p":{"lines":[59,60],"index":1},"v":"1. Promise回调"},{"t":"list_item","d":7,"p":{"lines":[60,61],"index":2},"v":"2. async/await中await后方代码"}]},{"t":"heading","d":5,"p":{"lines":[62,63]},"v":"MutationObserver"},{"t":"heading","d":5,"p":{"lines":[66,67]},"v":"process.nextTick（Node）"}]}]}]},{"t":"heading","d":2,"p":{"lines":[70,71]},"v":"浏览器事件循环","c":[{"t":"heading","d":3,"p":{"lines":[72,73]},"v":"浏览器事件循环的结构","c":[{"t":"heading","d":4,"p":{"lines":[74,75]},"v":"执行栈（Call Stack）","c":[{"t":"heading","d":5,"p":{"lines":[76,77]},"v":"存储函数调用的栈结构","c":[{"t":"list_item","d":7,"p":{"lines":[78,79],"index":1},"v":"1. 遵循先进后出"},{"t":"list_item","d":7,"p":{"lines":[79,80],"index":2},"v":"2. 可存放函数有限制，过多的函数会造成爆栈"}]},{"t":"heading","d":5,"p":{"lines":[81,82]},"v":"执行栈的执行过程","c":[{"t":"list_item","d":7,"p":{"lines":[83,84],"index":1},"v":"1. 执行代码时遇见函数则入栈，同步代码直接执行，异步事件放入对应线程处理"},{"t":"list_item","d":7,"p":{"lines":[84,85],"index":2},"v":"2. 当函数执行完成后出栈"}]}]},{"t":"heading","d":4,"p":{"lines":[86,87]},"v":"浏览器定义的APIs（Web APIs）"},{"t":"heading","d":4,"p":{"lines":[90,91]},"v":"事件队列（Task Queue）","c":[{"t":"heading","d":5,"p":{"lines":[94,95]},"v":"事件队列执行方式","c":[{"t":"list_item","d":7,"p":{"lines":[96,97],"index":1},"v":"1. 一次只执行一个事件"},{"t":"list_item","d":7,"p":{"lines":[97,98],"index":2},"v":"2. 当有新事件加入时并不会立即执行"}]},{"t":"heading","d":5,"p":{"lines":[99,100]},"v":"注意！！！鼠标点击元素和调用click方法触法时不同的","c":[{"t":"list_item","d":7,"p":{"lines":[101,102],"index":1},"v":"1. clik触发多个点击事件是所有宏任务处理完再处理微任务"},{"t":"list_item","d":7,"p":{"lines":[102,103],"index":2},"v":"2. 执行栈中clik一直在，所以微任务不执行"}]}]},{"t":"heading","d":4,"p":{"lines":[104,105]},"v":"微任务队列（Microtask Queue）","c":[{"t":"heading","d":5,"p":{"lines":[108,109]},"v":"微任务队列执行方式","c":[{"t":"list_item","d":7,"p":{"lines":[110,111],"index":1},"v":"1. 一直执行，直到队列清空"},{"t":"list_item","d":7,"p":{"lines":[111,112],"index":2},"v":"2. 当执行过程中有新事件加入时，也会直接执行"},{"t":"list_item","d":7,"p":{"lines":[112,113],"index":3},"v":"3. 由于微任务处理是同步的，过多的任务会阻塞渲染"}]}]},{"t":"heading","d":4,"p":{"lines":[114,115]},"v":"渲染队列（Animation callback）","c":[{"t":"heading","d":5,"p":{"lines":[118,119]},"v":"渲染队列执行方式","c":[{"t":"list_item","d":7,"p":{"lines":[120,121],"index":1},"v":"1. 一直执行，直到当前帧队列清空"},{"t":"list_item","d":7,"p":{"lines":[121,122],"index":2},"v":"2. 当有新事件加入时，只会将当前帧的处理完，执行过程中新加入的下次帧时执行"}]},{"t":"heading","d":5,"p":{"lines":[125,126]},"v":"<a href=\"https://ginobilee.github.io/blog/2019/02/01/requestAnimationFrame%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B9%88/\">requestAnimationFrame是一个宏任务么</a>","c":[{"t":"list_item","d":7,"p":{"lines":[127,128],"index":1},"v":"1. 宏任务与raf任务有明显的差异","c":[{"t":"list_item","d":9,"p":{"lines":[128,129],"index":1},"v":"1. 执行时机不同"},{"t":"list_item","d":9,"p":{"lines":[129,130],"index":2},"v":"2. raf任务队列被执行时，会将其此刻队列中所有任务都执行完"}]},{"t":"list_item","d":7,"p":{"lines":[130,131],"index":2},"v":"2. 所以raf任务不属于宏任务，而由于微任务的特殊性(单独的任务队列)，它显然更不是微任务"}]}]}]},{"t":"heading","d":3,"p":{"lines":[132,133]},"v":"浏览器事件循环的执行顺序","c":[{"t":"list_item","d":5,"p":{"lines":[136,137],"index":1},"v":"1. 执行栈为空（当前宏任务结束）"},{"t":"list_item","d":5,"p":{"lines":[137,138],"index":2},"v":"2. 清空微任务队列，将微任务队列中的事件放至执行栈执行"},{"t":"list_item","d":5,"p":{"lines":[138,139],"index":3},"v":"3. 页面UI渲染"},{"t":"list_item","d":5,"p":{"lines":[139,140],"index":4},"v":"4. 触发Event Loop，将事件队列中事件回调放入执行栈中执行"},{"t":"list_item","d":5,"p":{"lines":[140,141],"index":5},"v":"5. 执行代码，清空执行栈，开启下次循环"}]}]},{"t":"heading","d":2,"p":{"lines":[142,143]},"v":"<a href=\"https://juejin.cn/post/6844903999506923528#heading-5\">Node事件循环</a>","c":[{"t":"heading","d":3,"p":{"lines":[146,147]},"v":"Node循环阶段","c":[{"t":"heading","d":4,"p":{"lines":[150,151]},"v":"Timers（定时器阶段）"},{"t":"heading","d":4,"p":{"lines":[154,155]},"v":"I/O callbacks（I/O回调阶段)"},{"t":"heading","d":4,"p":{"lines":[158,159]},"v":"idle, prepare 阶段"},{"t":"heading","d":4,"p":{"lines":[162,163]},"v":"poll（轮询阶段）"},{"t":"heading","d":4,"p":{"lines":[168,169]},"v":"Check（查询阶段）"},{"t":"heading","d":4,"p":{"lines":[172,173]},"v":"Close callbacks"}]},{"t":"heading","d":3,"p":{"lines":[176,177]},"v":"process.nextTick","c":[{"t":"list_item","d":5,"p":{"lines":[178,179],"index":1},"v":"1. 独立于 Event Loop 之外的，拥有一个自己的队列"},{"t":"list_item","d":5,"p":{"lines":[179,180],"index":2},"v":"2. 每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数"},{"t":"list_item","d":5,"p":{"lines":[180,181],"index":3},"v":"3. 优先于microtask执行"}]}]}]})</script>
</body>
</html>
