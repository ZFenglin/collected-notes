# 模板编译

vue实例初始化结尾触发vm.$mount(vm.$options.el)，开始进行模板编译和元素挂载

模板编译从$mount开始

## Vue.prototype.$mount

处理元素的创建和挂载

由于这个方法和平台相关，vue将其放在了src\platforms文件夹下

同时Vue.prototype.$mount存在两个地方进行做了处理

### 各个平台公共的mount

位于src\platforms\web\runtime\index.js

公共的$mount方法，会在各个平台下重写

```JS
// 设置__patch__
Vue.prototype.__patch__ = inBrowser ? patch : noop

// 公共的mount方法
Vue.prototype.$mount = function(el, hydrating) {
    // 获取元素
    el = el && inBrowser ? query(el) : undefined
    // 组件挂载
    return mountComponent(this, el, hydrating)
}
```

### web平台独有的mount

位于src\platforms\web\entry-runtime-with-compiler.js

只处理web下的情形

1. 获取当前元素
2. render函数获取
   1. template模板获取
   2. 通过模板获取render
3. 执行公共mount

```JS
// 公共mount备份
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function(el, hydrating) {
    // 1. 获取当前元素
    el = el && query(el)
    // 对于body和documentElement直接返回
    if (el === document.body || el === document.documentElement) {
        return this
    }
    // 2. render函数获取
    const options = this.$options
    if (!options.render) {
        // 2.1 模板获取
        let template = options.template
        if (template) {
            if (typeof template === 'string') {
                if (template.charAt(0) === '#') {
                    template = idToTemplate(template)
                }
            } else if (template.nodeType) {
                template = template.innerHTML
            } else {
                return this
            }
        } else if (el) {
            template = getOuterHTML(el)
        }
        // 2.2 通过模板获取render
        if (template) {
            const {
                render,
                staticRenderFns
            } = compileToFunctions(template, {
                outputSourceRange: process.env.NODE_ENV !== 'production',
                shouldDecodeNewlines,
                shouldDecodeNewlinesForHref,
                delimiters: options.delimiters,
                comments: options.comments
            }, this)
            options.render = render
            options.staticRenderFns = staticRenderFns
        }
    }
    // 3. 执行公共mount
    return mount.call(this, el, hydrating)
}
```

从render函数获取可以知道，组件渲染配置优先级上render > template > el

## render函数获取

mount中compileToFunctions处理后获取render函数

compileToFunctions则是由compiler\index中的createCompiler传入参数获取的

而传入其中的baseCompile做了以下步骤

1. 解析template获取ast
2. 静态节点处理
3. ast转化为执行代码

```JS
export const createCompiler = createCompilerCreator(function baseCompile(template, options) {
    // 解析template获取ast
    const ast = parse(template.trim(), options)
    // 静态节点处理
    if (options.optimize !== false) {
        optimize(ast, options)
    }
    // ast转化为执行代码
    const code = generate(ast, options)
    return {
        ast,
        render: code.render,
        staticRenderFns: code.staticRenderFns

    }
})
```

### 解析template

#### parse

创建相关属性，并在最后执行parseHTML解析HTML

```JS
export function parse(template, option) {
    // 相关属性处理
    // ...
    const stack = [] // 处理父子元素关系栈
    let root // 设置实例根元素
    // ...
    // 相关方法声明
    function warnOnce(msg, range) {
        // ...
    }

    function closeElement(element) {
        // ...
    }

    function trimEndingWhitespace(el) {
        // ...
    }

    function checkRootConstraints(el) {
        //...
    }
    // 执行parseHTML
    parseHTML(template, {
        // 方法其它配置
        // ...
        // 解析对应位置回调
        start(tag, attrs, unary, start, end) {
            // ...
        },
        end(tag, start, end) {
            // ...
        },
        chars(text: string, start: number, end: number) {
            // ...
        },
        comment(text: string, start, end) {
            // ...
        }
    })
    return root
}
```

##### start

解析开始标签回调

1. 创建元素
2. 根元素判断赋值
3. 当前元素父元素设置和父元素的children设置
4. 栈中添加当前元素

```JS
start(tag, attrs, unary, start, end) {
    // ...
    // 1. 创建元素element
    let element = createASTElement(tag, attrs, currentParent)
    // ...
    // 2. 根元素判断赋值
    if (!root) {
        root = element
    }
    // ...
    // currentParent设置为当前元素并且元素入栈
    if (!unary) {
        currentParent = element
        stack.push(element)
    } else {
        closeElement(element)
    }
}
```

##### end

解析结束标签回调

弹出栈顶元素，判断栈顶元素是否与当前元素匹配

```JS
end(tag, start, end) {
    const element = stack[stack.length - 1]
    // pop stack
    stack.length -= 1
    currentParent = stack[stack.length - 1]
    closeElement(element)
},
```

##### chars

解析文本标签

1. 获取当前父亲元素的children
2. 处理传入的text
3. text存在，则按条件创建type为2或者3的节点对象
4. 将节点添加至父元素的children

```JS
chars(text, start, end) {
    // 1. 获取当前父亲元素的children
    const children = currentParent.children
    // 2. 处理传入的text
    // ...
    if (text) {
        if (!inPre && whitespaceOption === 'condense') {
            text = text.replace(whitespaceRE, ' ')
        }
        let res
        let child
        // 3. text存在，则按条件创建type为2或者3的节点对象
        // ...
        // 4. 将节点添加至父元素的children
        if (child) {
            children.push(child)
        }
    }
},
```

##### comment

解析注释文本

```JS
comment(text, start, end) {
    if (currentParent) {
        const child: ASTText = {
            type: 3,
            text,
            isComment: true
        }
        currentParent.children.push(child)
    }
}
```

#### parseHTML

解析html模板，并会在合适时机调用传入的钩子函数

while (html)循环解析，处理完后会用advance截取html

> 纯文本标签: 包括：script、style、textarea，isPlainTextElement用于判断

这里我们只关注非纯文本标签处理

End tag: 结束标签处理
1. 正则匹配结束标签，获取结果endTagMatch
2. 更新curIndex
3. advance截取处理过部分
4. parseEndTag处理其它并触发options.end回调

Start tag: 开始标签处理
1. parseStartTag解析开始标签
2. handleStartTag处理其它并触发options.start回调

Char： 文档标签处理
1. 获取剩余文本text
2. advance截取文本
3. 触发options.chars回调

```JS
export function parseHTML(html, options) {
    const stack = []
    const expectHTML = options.expectHTML
    const isUnaryTag = options.isUnaryTag || no
    const canBeLeftOpenTag = options.canBeLeftOpenTag || no
    let index = 0
    let last, lastTag
    while (html) {
        last = html
        if (!lastTag || !isPlainTextElement(lastTag)) {
            // 解析非纯文本标签处理
            let textEnd = html.indexOf('<')
            if (textEnd === 0) {
                // Comment: 注释开头处理
                // ...
                // Doctype: 文档标签处理
                // ...
                // End tag: 结束标签处理
                const endTagMatch = html.match(endTag)
                if (endTagMatch) {
                    const curIndex = index
                    advance(endTagMatch[0].length)
                    parseEndTag(endTagMatch[1], curIndex, index)
                    continue
                }
                // Start tag: 开始标签处理
                const startTagMatch = parseStartTag()
                if (startTagMatch) {
                    handleStartTag(startTagMatch)
                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
                        advance(1)
                    }
                    continue
                }
            }
            // 文档标签处理
            let text, rest, next
            if (textEnd >= 0) {
                // ...
                text = html.substring(0, textEnd)
            }
            if (textEnd < 0) {
                text = html
            }
            if (text) {
                advance(text.length)
            }
            if (options.chars && text) {
                options.chars(text, index - text.length, index)
            }
        } else {
            // 解析纯文本标签处理
            // ...
        }
        // 整个字符串作为文本处理 
        // ...
    }
    // 清理剩余标签
    parseEndTag()
    // 处理解析html的函数
    function advance(n) {
        // ...
    }

    function parseStartTag() {
        // ...
    }

    function handleStartTag(match) {
        // 处理其它并触发options.start回调
        // ...
    }

    function parseEndTag(tagName, start, end) {
        // 处理其它并触发options.end回调
        // ...
    }
}
```

parseHTML内部存在多个解析标签方法

##### 截取html

利用substring截取n长度的html

```JS
function advance(n) {
    index += n
    html = html.substring(n)
}
```

##### 解析开始标签

1. match正则匹配获取结果start
2. 创建match用于组成返回值
3. 处理start，匹配获取属性并填入attrs，advance截取处理过部分
5. 返回match

```JS
function parseStartTag() {
    // 1. match正则匹配获取结果start
    const start = html.match(startTagOpen)
    if (start) {
        // 2. 创建match用于组成返回值
        const match = {
            tagName: start[1],
            attrs: [],
            start: index
        }
        advance(start[0].length)
        // 3. 处理start，匹配获取属性并填入attrs，advance截取处理过部分
        let end, attr
        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
            attr.start = index
            advance(attr[0].length)
            attr.end = index
            match.attrs.push(attr)
        }
        // 4. 返回match
        if (end) {
            match.unarySlash = end[1]
            advance(end[0].length)
            match.end = index
            return match
        }
    }
}
```

### 静态节点处理

遍历树将静态节点进行标记，并在下次渲染不会重新处理

```JS
export function optimize(root, options) {
    if (!root) return
    isStaticKey = genStaticKeysCached(options.staticKeys || '')
    isPlatformReservedTag = options.isReservedTag || no
    // first pass: mark all non-static nodes.
    markStatic(root)
    // second pass: mark static roots.
    markStaticRoots(root, false)
}
```

### ast转化为执行代码

将传入的ast对象树转化为嵌套方法

```JS
export function generate(ast, options) {
    // 获取state，存储相关状态
    const state = new CodegenState(options)
    // genElement处理代码生成
    const code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c("div")'
    // 返回处理好的render对象
    return {
        render: `with(this){return ${code}}`,
        staticRenderFns: state.staticRenderFns
    }
}
```

genElement用于处理渲染函数代码生成

通过判断不同的ast类型，分别处理

```JS
export function genElement(el, state) {
    if (el.parent) {
        el.pre = el.pre || el.parent.pre
    }
    if (el.staticRoot && !el.staticProcessed) {
        return genStatic(el, state)
    } else if (el.once && !el.onceProcessed) {
        return genOnce(el, state)
    } else if (el.for && !el.forProcessed) { // v-for
        return genFor(el, state)
    } else if (el.if && !el.ifProcessed) { // v-if
        return genIf(el, state)
    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
        return genChildren(el, state) || 'void 0'
    } else if (el.tag === 'slot') {
        return genSlot(el, state)
    } else {
        // 元素或者组件
        let code
        if (el.component) {
            // 组件代码生成
            code = genComponent(el.component, el, state)
        } else {
            // 元素代码生成
            let data
            if (!el.plain || (el.pre && state.maybeComponent(el))) {
                data = genData(el, state)
            }
            // 1. 获取children代码
            const children = el.inlineTemplate ? null : genChildren(el, state, true)
            // 2. 代码拼接
            code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
        }
        // module transforms
        for (let i = 0; i < state.transforms.length; i++) {
            code = state.transforms[i](el, code)
        }
        return code
    }
}
```

## 元素挂载

各平台的render函数获取到后，就会执行公共的mount，最终触发mountComponent方法

### mountComponent

处理组件渲染

1. 没有render则渲染空节点
2. 创建updateComponent负责组件首次渲染和后续更新
3. 创建组件渲染Watcher，即一个vue的实例只有一个渲染watcher

```JS
export function mountComponent(vm, el, hydrating) {
    vm.$el = el
    // 没有render则渲染空节点
    if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode
    }
    callHook(vm, 'beforeMount')
    // updateComponent负责组件首次渲染和后续更新
    let updateComponent
    updateComponent = () => {
        vm._update(vm._render(), hydrating)
    }
    // 创建组件渲染Watcher，即一个vue的实例只有一个渲染watcher
    new Watcher(vm, updateComponent, noop, {
        before() {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook(vm, 'beforeUpdate')
            }
        }
    }, true /* isRenderWatcher */ )
    // 非服务端渲染
    hydrating = false
    if (vm.$vnode == null) {
        vm._isMounted = true
        callHook(vm, 'mounted')
    }
    return vm
}
```
#### _render

#### _update