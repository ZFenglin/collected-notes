# 优化网址性能

## 区分环境

代码开发过程中存在多套运行环境，针对不同的运行环境则编译不同代码，比如以下情况

### 区分环境目的

1. 是否代码压缩
2. 开发日志是否展示
3. API接口地址更改

项目中使用 `process.env.NODE_ENV` 获取设置的环境字符串

### 区分环境设置方式

引入DefinePlugin插件

```JS
// 传入参数
'process.env': {
    NODE_ENV: JSON.stringify('production')
}
```

可以与UglifyJS处理掉判断环境的代码，只执行当前环境的代码

## 压缩代码

### 压缩JS

1. UglifyJsPlugin
2. ParallelUglifyPlugin

UglifyJsPlugin处理ES6代码会报错，所以专门分出一个用于处理ES6的分支
1. UglifyESPlugin

### 压缩CSS

1. cssnano（删除空格，简化CSS表达式）
2. OptimizeCssAssetsPlugin

开启方式为css-loader的minimize选项

```JS
use: ['css-loader?minimize']
```

### 压缩HTML

插件为html-webpack-plugin

参数为以下
1. removeComments: true（移除HTML中的注释）
2. collapseWhitespace: true（删除空白符与换行符）
3. minifyCSS: true（压缩内联CSS）

## CDN加速

### CDN加速注意部分

CDN服务通常会为资源开启长时间缓存，造成HTML文件更新了但是不刷新
1. 针对HTML文件：HTML文件放在自己的服务器上，同时关闭自己服务器的缓存
2. 针对静态JavaScript等文件：开启CDN和缓存，放到CDN服务器上，同时文件名需要带上文件内容得出的hash值

### 并行加载处理

浏览器在同一时刻对同一域名的请求有数量限制，所有资源放在一个CDN服务器下，则会出现阻塞
   
处理方式是将不同的资源放到不同的CDN服务上

但是会出现增加域名解析问题，在head中增加预解析域名

```HTML
<link rel="dns-prefetch" href="//js.cdn.com">
```

### Webpack实现CDN接入

实现要求
1. 静态资源导入URL变成执行CDN服务的地址
2. 静态文件名称需要内容得出的hash值
3. 不同资源放在不同的CDN服务上

设置方式
1. output.publicPath设置JavaScript的地址
2. css-loader.publicPath设置被导入CSS资源地址
3. WebPlugin.stylePublicPath中设置CSS文件的地址

## Tree Shaking

依赖于静态的ES6的模块化

### Tree Shaking的Webpack配置

保留模块化，修改.babelrc

```JS
presets: [
    [env, {
        modules: false
    }]
]
```

启动参数增加--display-used-exports参数

设置UglifyJS，webpack只是指出那些方法未使用，需要设置UglifyJS来简化代码

### 社区依赖包处理

Npm大部分的包都是CommonJS，不支持

但是这些库提供CommonJS和ES6的代码，利用mainFields来配置使用ES6的方式

## 提取公共代码

### 提取公共代码好处

1. 减少网络流量
2. 提升后续其它页面的加载速度

### 抽离原则

1. 网站使用的技术栈基本代码，如react，vue，存放在base.js
2. 所有页面共有代码，存放在common.js中

### webpack处理插件

1. CommonsChunkPlugin（弃用）
2. SplitChunksPlugin

## 分割代码并按需加载

网站按照功能分出类别，每个类别对应一个Chunk，分割出去的代码在特定时机触发加载

```JS
import( /* webpackChunkName: "show" */ './show').then((show) => show())
```

webpack在遇到/* webpackChunkName: "show" */会进行以下处理
1. 以./show.js重新创建一个Chunk
2. 当代码执行到import才会加载文件
3. import返回一个Promise，then后才能执行

同时指定output设置对应文件输出文件名称

```JS
chunkFilename: '[name].js',
```

## Scope Hoisting

作用域提升, 将文件导出合并至一个文件中

提升具有以下优势
1. 代码体积小
2. 作用域变少，内存开销减少

## Scope Hoisting设置方式

使用Webpack自带的ModuleConcatenationPlugin插件

但是只支持ES6模块化，resolve.mainFields: ['jsnext:main', 'browser', 'main']，从而优先使用ES6代码

## 其它方式

### Prepack

按照执行结果生成最简化代码，但是局限大，不适合线上环境

### 图片处理

1. 压缩图片：ImageminWebpackLoader
2. 小图片base64编码：url-loader

### 无效CSS清除

1. mini-css-extract-plugin：前提，抽离CSS
2. purgecss-webpack-plugin：清理无效CSS

### 预先加载

先加载本页面需要用到的关键资源

```JS
/* webpackPreload: true */
```

### 预先拉取

在浏览器空闲的时候加载未来可能会用到的资源

```JS
/* webpackPrefetch: true */
```

## 输出性能分析

1. Webpack Analyse（官方）
2. webpack-bundle-analyzer
