# [面向对象](https://tsejx.github.io/javascript-guidebook/object-oriented-programming)

理解面向对象，首先需要理解new这个操作符的原理，可以看this绑定部分

详细代码见手写代码/对象相关

## 创建对象

### 工厂模式

创建对象的一种最常用的设计模式

1. 工厂模式不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂
2. 缺点是没有建立起对象和类型间的关系
3. React.createElement()、Vue.component() 都是工厂模式的实现

### 构造函数模式

1. 函数内使用this增加属性
2. 使用时使用new创建对象

#### 与工厂模式区别

1. 没有显式地创建对象
2. 直接将属性和方法赋给了 this 对象
3. 没有 return 语句
4. 虽然建立的联系，但是会有重复的实例方法的创建

### 原型模式

1. 将实例的属性和方法都放在构造函数的prototype上
2. 利用new操作符创建对象

#### 与构造函数模式区别

1. 虽然不会有重复属性创建
2. 但是也会造成新对象的这些属性和方法是由所有实例共享的
3. 并且无法通过传参赋值

### 组合使用构造函数模式和原型模式（首选）

结合了双方的优势，目前最流行的创建方式
1. 支持参数初始化实例属性，兼顾了方法的复用性和属性的独立性
2. 但是代码封装性不太好

### 动态原型模式

1. 动态原型模式将所有信息都封装在构造函数中
2. 而通过构造函数中初始化原型
3. 相比组合使用构造函数模式和原型模式，提升了封装性

### 寄生构造函数模式（不推荐）

1. 基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象
2. 没有建立起对象和类型间的关系

### 稳妥构造函数模式（不推荐）

1. 稳妥对象，指的是没有公共属性，而且其方法不引用 this 的对象
2. 稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序改动时使用
3. 没有建立起对象和类型间的关系

## 继承对象

### 原型链

1. 将子类对象的prototype指向父类new出的实例上
2. 在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱
3. 还有就是在创建子类型的时候不能向超类型传递参数

### 借用构造函数

1. 在子类型构造函数的内部调用父类构造函数以实现对父类构造函数属性的继承
2. 可以在子类型构造函数中向父类型构造函数传递参数
3. 只能继承父类实例对象的属性和方法，不能继承原型对象的属性和方法
4. 无法实现复用，每个子类都有父类实例函数的副本，影响性能

### 组合继承

1. 将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式
2. 都会调用两次父类构造函数：第一次是在创建子类型原型的时候，另一次是在子类型构造函数内部，造成属性重复

### 原型式继承（Object.create()原理）

1. 引用类型值的属性始终都会共享相应的值
2. 多个实例对象对引用类型的操作会被篡改

### 寄生式继承

1. 创建一个原型式继承的对象，并在函数内部以某种方式增强对象
2. 只适用于对象，而不是自定义类型和构造函数的情况下

### 寄生组合式继承（首选）

1. 只调用了一次 Parent 构造函数，并且因此避免了在 Child.prototype 上面创建不必要的、多余的属性。
2. 与此同时，原型链还保持不变
