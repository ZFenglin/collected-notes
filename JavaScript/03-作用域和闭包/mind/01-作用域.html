<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"作用域","c":[{"t":"heading","d":2,"p":{"lines":[6,7]},"v":"作用域的作用","c":[{"t":"list_item","d":4,"p":{"lines":[8,9],"index":1},"v":"1. 让内部的作用域可以访问到外部的变量"},{"t":"list_item","d":4,"p":{"lines":[9,10],"index":2},"v":"2. 保证执行环境的所有变量有序访问","c":[{"t":"list_item","d":6,"p":{"lines":[10,11],"index":1},"v":"1. 变量合法使用范围"},{"t":"list_item","d":6,"p":{"lines":[11,12],"index":2},"v":"2. 让变量不会外泄和暴露"}]}]},{"t":"heading","d":2,"p":{"lines":[13,14]},"v":"编译原理","c":[{"t":"heading","d":3,"p":{"lines":[17,18]},"v":"传统编译语言执行前步骤","c":[{"t":"list_item","d":5,"p":{"lines":[19,20],"index":1},"v":"1. 分词/词法分析（Tokenizing/Lexing）：由字符组成的字符串分解成（对编程语言来说）有意义的代码块"},{"t":"list_item","d":5,"p":{"lines":[20,21],"index":2},"v":"2. 解析/语法分析（Parsing）：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树（AST）"},{"t":"list_item","d":5,"p":{"lines":[21,22],"index":3},"v":"3. 代码生成：将 AST 转换为可执行代码"}]},{"t":"heading","d":3,"p":{"lines":[23,24]},"v":"JavaScript执行前步骤","c":[{"t":"list_item","d":5,"p":{"lines":[27,28],"index":1},"v":"1. 遇到变量声明，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中","c":[{"t":"list_item","d":7,"p":{"lines":[28,29],"index":1},"v":"1. 如果是，编译器会忽略该声明，继续进行编译"},{"t":"list_item","d":7,"p":{"lines":[29,30],"index":2},"v":"2. 否则它会要求作用域在当前作用域的集合中声明一个新的变量"}]},{"t":"list_item","d":5,"p":{"lines":[30,31],"index":2},"v":"2. 接下来编译器会为引擎生成运行时所需的代码，当处理变量赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在对应变量","c":[{"t":"list_item","d":7,"p":{"lines":[31,32],"index":1},"v":"1. 如果是，引擎就会使用这个变量"},{"t":"list_item","d":7,"p":{"lines":[32,33],"index":2},"v":"2. 如果否，引擎会继续向上查找该变量"}]}]}]},{"t":"heading","d":2,"p":{"lines":[36,37]},"v":"作用域分类","c":[{"t":"heading","d":3,"p":{"lines":[42,43]},"v":"全局作用域","c":[{"t":"ordered_list","d":4,"p":{"lines":[44,47],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[44,45],"index":1},"v":"1. 全局作用域是全局有效的"},{"t":"list_item","d":5,"p":{"lines":[45,46],"index":2},"v":"2. 但是过多的全局作用域变量会污染空间，出现命名冲突，利用函数作用域将变量包裹起来，例如Jquery"}]},{"t":"heading","d":4,"p":{"lines":[47,48]},"v":"创建方式","c":[{"t":"list_item","d":6,"p":{"lines":[49,50],"index":1},"v":"1. 最外层的函数或最外层函数外部定义的变量"},{"t":"list_item","d":6,"p":{"lines":[50,51],"index":2},"v":"2. 未通过var，let或const定义的变量"}]}]},{"t":"heading","d":3,"p":{"lines":[52,53]},"v":"函数作用域","c":[{"t":"ordered_list","d":4,"p":{"lines":[54,56],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[54,55],"index":1},"v":"1. 有效范围仅限当前声明的函数内部"}]},{"t":"heading","d":4,"p":{"lines":[56,57]},"v":"创建方式","c":[{"t":"list_item","d":6,"p":{"lines":[58,59],"index":1},"v":"1. 函数内部的var定义变量"},{"t":"list_item","d":6,"p":{"lines":[59,60],"index":2},"v":"2. 或者let或const位于函数顶层定义的变量"}]}]},{"t":"heading","d":3,"p":{"lines":[61,62]},"v":"块级作用域","c":[{"t":"ordered_list","d":4,"p":{"lines":[63,66],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[63,64],"index":1},"v":"1. 代码块就是由{}包裹的代码范围"},{"t":"list_item","d":5,"p":{"lines":[64,65],"index":2},"v":"2. 块级作用域仅限代码块中的变量有效"}]},{"t":"heading","d":4,"p":{"lines":[66,67]},"v":"创建方式","c":[{"t":"list_item","d":6,"p":{"lines":[68,69],"index":1},"v":"1. 在代码块中使用let或const声明的变量具有块级作用域"}]}]}]},{"t":"heading","d":2,"p":{"lines":[70,71]},"v":"作用域链","c":[{"t":"heading","d":3,"p":{"lines":[74,75]},"v":"自由变量","c":[{"t":"list_item","d":5,"p":{"lines":[76,77],"index":1},"v":"1. 当前为使用var，let和const声明而直接使用的变量"},{"t":"list_item","d":5,"p":{"lines":[77,78],"index":2},"v":"2. 而自由变量不断向上寻找对应变量的过程就是作用域链"}]},{"t":"heading","d":3,"p":{"lines":[79,80]},"v":"查找方式","c":[{"t":"list_item","d":5,"p":{"lines":[81,82],"index":1},"v":"1. 自由变量会首先在当前作用域寻找，如果没有找到则会向上级作用域寻找，直到找到全局作用域"},{"t":"list_item","d":5,"p":{"lines":[82,83],"index":2},"v":"2. 在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）"},{"t":"list_item","d":5,"p":{"lines":[83,84],"index":3},"v":"3. 在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常"}]}]}]})</script>
</body>
</html>
