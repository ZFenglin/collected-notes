# 异步编程

## 回调函数与定时器

```js
/**
 * requestAnimationFrame模拟定时器
 * @param {*} callback 
 * @param {*} interval 
 * @returns 
 */
function setInterval(callback, interval) {
    let timer
    const now = Date.now
    let startTime = now()
    let endTime = startTime
    const loop = () => {
        timer = window.requestAnimationFrame(loop)
        endTime = now()
        if (endTime - startTime >= interval) {
            startTime = endTime = now()
            callback(timer)
        }
    }
    timer = window.requestAnimationFrame(loop)
    return timer
}
```

## Promise

### 手写promise

```js
class _Promise {
    static PENDING = '待定'
    static FULFILLED = '兑现'
    static REJECTED = '拒绝'
    status = _Promise.PENDING
    result = undefined
    resolveCallbacks = []
    rejectCallbacks = []

    constructor(executor) {
        const resolve = (value) => {
            setTimeout(() => {
                if (this.status === _Promise.PENDING) {
                    this.status = _Promise.FULFILLED
                    this.result = value
                    this.resolveCallbacks.forEach(cb => cb())
                }
            });
        }
        const reject = (value) => {
            setTimeout(() => {
                if (this.status === _Promise.PENDING) {
                    this.status = _Promise.REJECTED
                    this.result = value
                    this.rejectCallbacks.forEach(cb => cb())
                }
            });
        }
        try {
            executor(resolve, reject)
        } catch (error) {
            reject(error)
        }
    }

    handlePromise(fn, resolve, reject, resolved = true) {
        try {
            let x = fn(this.result)
            if (x instanceof _Promise) {
                x.then(resolve, reject)
            } else {
                resolved ? resolve(x) : reject(x)
            }
        } catch (error) {
            reject(error)
        }
    }

    then(onResolved, onRejected) {
        return new _Promise((resolve, reject) => {
            let resolvedFn = typeof onResolved === 'function' ? () => this.handlePromise(onResolved, resolve, reject, true) : () => {}
            let rejectedFn = typeof onRejected === 'function' ? () => this.handlePromise(onRejected, resolve, reject, false) : () => {}
            switch (this.status) {
                case _Promise.FULFILLED:
                    resolvedFn()
                    break;
                case _Promise.REJECTED:
                    rejectedFn()
                    break;
                case _Promise.PENDING:
                    this.resolveCallbacks.push(() => resolvedFn())
                    this.rejectCallbacks.push(() => rejectedFn())
                    break;
            }
        })
    }

    catch (onRejected) {
        return this.then(null, onRejected)
    }
}
```

### 手写Promise.all

```js
function promiseAll(promises) {
    return new Promise(function(resolve, reject) {
        // 类型判断
        if (!Array.isArray(promises)) {
            throw new TypeError('promise must be a array')
        }
        let count = 0
        let length = promises.length
        let promisesResults = []
        for (let index = 0; index < length; index++) {
            // 用Promise.resolve包裹传入promise参数，防止传入普通函数报错
            const promise = promises[index];
            Promise.resolve(promise).then(
                res => {
                    count++
                    promisesResults[index] = res
                    if (count === length) {
                        return resolve(promisesResults)
                    }
                },
                res => {
                    return reject(res)
                },
            )
        }
    })
}
```

### 手写Promise.race

```js
function promiseRace(promises) {
    return new Promise((resolve, reject) => {
        // 类型判断
        if (!Array.isArray(promises)) {
            throw new TypeError('promise must be a array')
        }
        for (let index = 0; index < promises.length; index++) {
            const promise = promises[index];
            Promise.resolve(promise).then(
                res => {
                    return resolve(res)
                },
                res => {
                    return reject(res)
                },
            )
        }
    })
}
```

## Generator

### 生成器执行器

```js
 function co(generator) {
     const iterator = generator();
     return new Promise(function(resolve, reject) {
         // 通过递归的方式遍历内部状态
         function diff(value) {
             ret = iterator.next(value);
             if (ret.done) return resolve(ret.value);
             Promise.resolve(ret.value).then(function(data) {
                 diff(data.toString())
             });
         }
         try {
             diff()
         } catch (err) {
             reject(err)
         }
     })

 }

 function readFile(url) {
     return new Promise(function(resolve, reject) {
         fs.readFile(url, function(error, data) {
             if (error) reject(error);
             resolve(data)
         })
     })
 }

 function* gen() {
     var f1 = yield readFile('./a.txt');
     console.log(f1)
     var f2 = yield readFile('./b.txt');
     console.log(f2)

 }
 co(gen)
```
