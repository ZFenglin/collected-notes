# 异步&事件循环

这个相关的问题推荐看以下笔记
1. [浏览器原理/进程和线程](../../浏览器原理/02-进程和线程.md)
2. [浏览器原理/事件循环](../../浏览器原理/04-事件循环.md)
3. [JavaScript/异步编程](../index.md)

## 01

```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    console.log(2);
});
promise.then(() => {
    console.log(3);
});
console.log(4);

/// 打印内容
// 1
// 2
// 4
```

由于promise内部并未调用resolve或reject，所以一直处于pending状态，从而then不会触发

## 02

```js
const promise1 = new Promise((resolve, reject) => {
    console.log('promise1') // 1
    resolve('resolve1')
})
const promise2 = promise1.then(res => {
    console.log(res) // 4
})
console.log('1', promise1); // 2
console.log('2', promise2); // 3

/// 打印内容
// promise1
// 1 Promise {<fulfilled>: 'resolve1'}
// 2 Promise {<pending>}
// resolve1
```

1. 第一遍同步执行1，2，3的console
   1. promise1为fulfilled，是因为已经resolve了
   2. promise2为pending，是因为then中没有返回值
2. 同步执行完成，处理微任务执行4的console

## 03

```js
Promise.resolve().then(() => {
    console.log('promise1');
    const timer2 = setTimeout(() => {
        console.log('timer2')
    }, 0)
});
const timer1 = setTimeout(() => {
    console.log('timer1')
    Promise.resolve().then(() => {
        console.log('promise2')
    })
}, 0)
console.log('start');

/// 打印内容
// start
// promise1
// timer1
// promise2
// timer2
```

1. 第一次事件循环
   1. promise1的then微任务注册
   2. timer1的宏任务注册
   3. 打印start
   4. 执行微任务
      1. 打印promise1
      2. 注册timer2的宏任务
2. 第二次事件循环（timer1宏任务）
   1. 打印timer1
   2. 注册promise2微任务
   3. 清空微任务
      1. 打印promise2
3. 第三次事件循环（timer2宏任务）
   1. 单元timer2

## 04

```js
const promise = new Promise((resolve, reject) => {
    resolve('success1');
    reject('error');
    resolve('success2');
});
promise.then((res) => {
    console.log('then:', res);
}).catch((err) => {
    console.log('catch:', err);
})

/// 打印内容
// then: success1
```

1. promise状态更新了就不会变动，所以该题只会触发success1的then

## 05

```js
Promise.resolve(1)
    .then(2)
    .then(Promise.resolve(3))
    .then(console.log)

/// 打印内容
// 1

// 此时的得到的Promise为Promise {<fulfilled>: undefined}
```

1. Promise.resolve的value为带有then方法的对象，则返回的promise状态由then决定，否则状态为fulfilled，返回值就是value
2. then的参数不为函数的话，则直接跳过，执行后面的then
3. then的函数执行，如果没有返回值，也按照fulfilled处理，并值为undefined

## 06

```js
Promise.resolve().then(() => {
    return new Error('error!!!')
}).then(res => {
    console.log("then: ", res)
}).catch(err => {
    console.log("catch: ", err)
})

/// 打印内容
// then:  Error: error!!!
```

1. 返回一个Error实例，并不是throw，不会触发catch

## 07

```js
const promise = Promise.resolve().then(() => {
    return promise;
})
promise.catch(console.err)

/// 打印内容
// Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>
```

1. promise的then或catch返回值不能为pormise本身，否则会死循环
