<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"编译与挂载","c":[{"t":"heading","d":2,"p":{"lines":[2,3]},"v":"渲染过程","c":[{"t":"ordered_list","d":3,"p":{"lines":[4,7],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[4,5],"index":1},"v":"1. 编译过程（外层mount）：template =(parse)=&gt; AST =(generate)=&gt; 获取render"},{"t":"list_item","d":4,"p":{"lines":[5,6],"index":2},"v":"2. 挂载过程（内部mount）：执行_render =(createElement)=&gt; vnode =&gt; 执行_update =(patch)=&gt; 真实元素"}]},{"t":"heading","d":3,"p":{"lines":[7,8]},"v":"模板编译原理","c":[{"t":"fence","d":4,"v":"<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">compileToFunctions</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> options <span class=\"token comment\">//省略}, this)</span>\n</code></pre>\n"},{"t":"heading","d":4,"p":{"lines":[15,16]},"v":"三个阶段","c":[{"t":"list_item","d":6,"p":{"lines":[17,18],"index":1},"v":"1. 解析阶段"},{"t":"list_item","d":6,"p":{"lines":[18,19],"index":2},"v":"2. 优化阶段"},{"t":"list_item","d":6,"p":{"lines":[19,20],"index":3},"v":"3. 生成阶段"}]},{"t":"heading","d":4,"p":{"lines":[21,22]},"v":"解析阶段","c":[{"t":"fence","d":5,"v":"<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> ast <span class=\"token operator\">=</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n</code></pre>\n"},{"t":"heading","d":5,"p":{"lines":[29,30]},"v":"解析过程","c":[{"t":"list_item","d":7,"p":{"lines":[31,32],"index":1},"v":"1. 正则解析模板"},{"t":"list_item","d":7,"p":{"lines":[32,33],"index":2},"v":"2. 解析到开始闭合标签，分别执行对应的回调函数"}]},{"t":"heading","d":5,"p":{"lines":[34,35]},"v":"AST类型","c":[{"t":"list_item","d":7,"p":{"lines":[36,37],"index":1},"v":"1. 1为普通元素"},{"t":"list_item","d":7,"p":{"lines":[37,38],"index":2},"v":"2. 2为表达式"},{"t":"list_item","d":7,"p":{"lines":[38,39],"index":3},"v":"3. 3为纯文本"}]}]},{"t":"heading","d":4,"p":{"lines":[40,41]},"v":"优化阶段","c":[{"t":"ordered_list","d":5,"p":{"lines":[42,47],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[42,43],"index":1},"v":"1. 遍历AST","c":[{"t":"list_item","d":8,"p":{"lines":[43,44],"index":1},"v":"1. 第一遍markStatic找到其中一些静态节点并标记"},{"t":"list_item","d":8,"p":{"lines":[44,45],"index":2},"v":"2. 第二遍markStaticRoots找到静态根节点"}]},{"t":"list_item","d":6,"p":{"lines":[45,46],"index":2},"v":"2. 下次diff时直接跳过，优化渲染性能"}]},{"t":"fence","d":5,"v":"<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">optimize</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n</code></pre>\n"}]},{"t":"heading","d":4,"p":{"lines":[51,52]},"v":"生成阶段","c":[{"t":"fence","d":5,"v":"<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> code <span class=\"token operator\">=</span> <span class=\"token function\">generate</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n</code></pre>\n"}]}]}]},{"t":"heading","d":2,"p":{"lines":[61,62]},"v":"虚拟DOM","c":[{"t":"heading","d":3,"p":{"lines":[65,66]},"v":"虚拟DOM的优点","c":[{"t":"list_item","d":5,"p":{"lines":[67,68],"index":1},"v":"1. 配合不同渲染工具使跨平台成为可能"},{"t":"list_item","d":5,"p":{"lines":[68,69],"index":2},"v":"2. 可以将多次DOM修改处理好后一次性更新到页面","c":[{"t":"list_item","d":7,"p":{"lines":[69,70],"index":1},"v":"1. 减少页面渲染次数"},{"t":"list_item","d":7,"p":{"lines":[70,71],"index":2},"v":"2. 减少DOM重排重绘"}]},{"t":"list_item","d":5,"p":{"lines":[71,72],"index":3},"v":"3. 无需手动操作DOM","c":[{"t":"list_item","d":7,"p":{"lines":[72,73],"index":1},"v":"1. 手动操作无法保证程序性能"},{"t":"list_item","d":7,"p":{"lines":[73,74],"index":2},"v":"2. 提升开发效率"}]}]},{"t":"heading","d":3,"p":{"lines":[75,76]},"v":"虚拟DOM解析过程","c":[{"t":"list_item","d":5,"p":{"lines":[77,78],"index":1},"v":"1. 将要插入到文档额DOM树结构进行分析，使用js对象表示"},{"t":"list_item","d":5,"p":{"lines":[78,79],"index":2},"v":"2. 页面改变，构建新树并和老树进行比较得出差异"},{"t":"list_item","d":5,"p":{"lines":[79,80],"index":3},"v":"3. 将差异应用到真正的DOM中，从而更新视图"}]},{"t":"heading","d":3,"p":{"lines":[81,82]},"v":"使用虚拟DOM的原因","c":[{"t":"list_item","d":5,"p":{"lines":[85,86],"index":1},"v":"1. 只是保证性能下限，在不手动优化的情况下，性能还可以","c":[{"t":"list_item","d":7,"p":{"lines":[86,87],"index":1},"v":"1. 真实DOM∶ 生成HTML字符串＋重建所有的DOM元素"},{"t":"list_item","d":7,"p":{"lines":[87,88],"index":2},"v":"2. 虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新"},{"t":"list_item","d":7,"p":{"lines":[88,89],"index":3},"v":"3. 虽然虚拟DOM在更新页面前，计算不同会消耗更多时间，但是这个性能消耗对比DOM操作就少很多"}]},{"t":"list_item","d":5,"p":{"lines":[89,90],"index":2},"v":"2. 生成结果时JS对象，可以很方便进行跨平台"}]},{"t":"heading","d":3,"p":{"lines":[91,92]},"v":"虚拟DOM性能真高于真实DOM吗","c":[{"t":"list_item","d":5,"p":{"lines":[93,94],"index":1},"v":"1. 首次渲染大量DOM，由于多一层虚拟DOM的计算，会慢于直接innerHTML直接插入"},{"t":"list_item","d":5,"p":{"lines":[94,95],"index":2},"v":"2. 真实DOM针对性优化下，速度还是快于虚拟DOM"},{"t":"list_item","d":5,"p":{"lines":[95,96],"index":3},"v":"3. 还是那么一句话虚拟DOM只是保证性能下限，在不手动优化的情况下，性能还可以"}]},{"t":"heading","d":3,"p":{"lines":[97,98]},"v":"DIFF原理","c":[{"t":"list_item","d":5,"p":{"lines":[102,103],"index":1},"v":"1. patchVnode","c":[{"t":"list_item","d":7,"p":{"lines":[103,104],"index":1},"v":"1. 比对节点本身，不同直接替换"},{"t":"list_item","d":7,"p":{"lines":[104,105],"index":2},"v":"2. 本身节点相同，patchVnode处理，当存在子节点","c":[{"t":"list_item","d":9,"p":{"lines":[105,106],"index":1},"v":"1. 新无旧有，移除所有子节点"},{"t":"list_item","d":9,"p":{"lines":[106,107],"index":2},"v":"2. 新有旧无，添加新节点"},{"t":"list_item","d":9,"p":{"lines":[107,108],"index":3},"v":"3. 都有，updateChildren比较（diff核心）"}]}]},{"t":"list_item","d":5,"p":{"lines":[109,110],"index":2},"v":"2. updateChildren","c":[{"t":"list_item","d":7,"p":{"lines":[110,111],"index":1},"v":"1. 旧节点为空处理"},{"t":"list_item","d":7,"p":{"lines":[111,112],"index":2},"v":"2. 头头相同，头节点后移"},{"t":"list_item","d":7,"p":{"lines":[112,113],"index":3},"v":"3. 尾尾相同，尾节点前移"},{"t":"list_item","d":7,"p":{"lines":[113,114],"index":4},"v":"4. 头尾相同，右移，旧头节点移动至旧尾节点后，头节点后移，尾节点前移"},{"t":"list_item","d":7,"p":{"lines":[114,115],"index":5},"v":"5. 尾头相同，左移，旧尾节点移动至旧头节点前，头节点后移，尾节点前移"},{"t":"list_item","d":7,"p":{"lines":[115,116],"index":6},"v":"6. 乱序处理","c":[{"t":"list_item","d":9,"p":{"lines":[116,117],"index":1},"v":"1. 获取旧节点映射oldKeyToIdx"},{"t":"list_item","d":9,"p":{"lines":[117,118],"index":2},"v":"2. 获取映射中与新头节点key相同的值"},{"t":"list_item","d":9,"p":{"lines":[118,119],"index":3},"v":"3. 是否存在映射的值","c":[{"t":"list_item","d":11,"p":{"lines":[119,120],"index":1},"v":"1. 不存在直接创建节点，并插到旧头节点之前"},{"t":"list_item","d":11,"p":{"lines":[120,121],"index":2},"v":"2. 存在，则获取节点，看节点是否相同分别处理"}]},{"t":"list_item","d":9,"p":{"lines":[122,123],"index":4},"v":"4. 新头节点index后移"}]},{"t":"list_item","d":7,"p":{"lines":[123,124],"index":7},"v":"7. 剩余节点处理","c":[{"t":"list_item","d":9,"p":{"lines":[125,126],"index":1},"v":"1. 新节点剩余，添加新节点"},{"t":"list_item","d":9,"p":{"lines":[126,127],"index":2},"v":"2. 旧节点剩余，删除旧节"}]}]}]},{"t":"heading","d":3,"p":{"lines":[128,129]},"v":"节点key的作用","c":[{"t":"heading","d":4,"p":{"lines":[130,131]},"v":"v-if 中使用 key","c":[{"t":"list_item","d":6,"p":{"lines":[132,133],"index":1},"v":"1. 当元素有类型相同的元素时，vue会进行复用"},{"t":"list_item","d":6,"p":{"lines":[133,134],"index":2},"v":"2. 当key值相同或者未设置时，这些元素自带的值不会丢失，例如input用户输入不会清除"},{"t":"list_item","d":6,"p":{"lines":[134,135],"index":3},"v":"3. 此时修改或添加key可以使元素不会被复用"}]},{"t":"heading","d":4,"p":{"lines":[136,137]},"v":"v-for 中使用 key","c":[{"t":"list_item","d":6,"p":{"lines":[138,139],"index":1},"v":"1. v-for渲染的列表，默认采用就地复用的策略，即列表数据顺序变化了，vue不是移动DOM，而是本地直接复用"},{"t":"list_item","d":6,"p":{"lines":[139,140],"index":2},"v":"2. 提供key值，帮助vue追踪元素，用移动取代复用"}]},{"t":"heading","d":4,"p":{"lines":[141,142]},"v":"使用key的优势","c":[{"t":"list_item","d":6,"p":{"lines":[143,144],"index":1},"v":"1. 更准确：存在key，vue不会就地复用，而是改用移动节点"},{"t":"list_item","d":6,"p":{"lines":[144,145],"index":2},"v":"2. 更快速：key的唯一性生成MAP来获取对应节点，速度比便利快"}]},{"t":"heading","d":4,"p":{"lines":[146,147]},"v":"index不可以作为key","c":[{"t":"list_item","d":6,"p":{"lines":[148,149],"index":1},"v":"1. 应为数组的index与项无关，和没写没区别"},{"t":"list_item","d":6,"p":{"lines":[149,150],"index":2},"v":"2. 依然会执行默认的原地复用"}]}]}]},{"t":"heading","d":2,"p":{"lines":[151,152]},"v":"slot","c":[{"t":"heading","d":3,"p":{"lines":[155,156]},"v":"slot分类","c":[{"t":"list_item","d":5,"p":{"lines":[157,158],"index":1},"v":"1. 默认插槽：solt没有name属性时的默认显示插槽，其实名称为default，只能有一个"},{"t":"list_item","d":5,"p":{"lines":[158,159],"index":2},"v":"2. 具名插槽：具有name属性的插槽，一个组件可以有多个"},{"t":"list_item","d":5,"p":{"lines":[159,160],"index":3},"v":"3. 作用域插槽：插槽内部可以获取子组件数据，父组件根据子组件数据决定子组件插槽如何渲染"}]},{"t":"heading","d":3,"p":{"lines":[161,162]},"v":"slot原理","c":[{"t":"list_item","d":5,"p":{"lines":[163,164],"index":1},"v":"1. 子组件实例化时，会获取父组件传入的slot标签内容，并存放在vm.$slot中","c":[{"t":"list_item","d":7,"p":{"lines":[164,165],"index":1},"v":"1. 默认插槽为vm.$slot.default"},{"t":"list_item","d":7,"p":{"lines":[165,166],"index":2},"v":"2. 具名插槽为vm.$slot.xxx"}]},{"t":"list_item","d":5,"p":{"lines":[166,167],"index":2},"v":"2. 组件渲染时，遇到slot标签，使用$slot中的内容进行替换，可以在插件处理时传入当前数据，此时就是作用域插槽"}]}]},{"t":"heading","d":2,"p":{"lines":[168,169]},"v":"keep-alive","c":[{"t":"heading","d":3,"p":{"lines":[172,173]},"v":"keep-alive属性","c":[{"t":"list_item","d":5,"p":{"lines":[174,175],"index":1},"v":"1. include：字符串或正则表达式，只有名称匹配的组件会被匹配"},{"t":"list_item","d":5,"p":{"lines":[175,176],"index":2},"v":"2. exclude：字符串或正则表达式，任何名称匹配的组件都不会被缓存"},{"t":"list_item","d":5,"p":{"lines":[176,177],"index":3},"v":"3. max：最多可以缓存多少组件实例"}]},{"t":"heading","d":3,"p":{"lines":[178,179]},"v":"LRU （least recently used）","c":[{"t":"list_item","d":5,"p":{"lines":[181,182],"index":1},"v":"1. 新数据插入到链表头部"},{"t":"list_item","d":5,"p":{"lines":[182,183],"index":2},"v":"2. 命中缓存时，将数据移动至链表头部"},{"t":"list_item","d":5,"p":{"lines":[183,184],"index":3},"v":"3. 链表满时，先丢弃尾部的数据"}]},{"t":"heading","d":3,"p":{"lines":[185,186]},"v":"实现方式","c":[{"t":"list_item","d":5,"p":{"lines":[187,188],"index":1},"v":"1. 判断当前组件的name，不在include和在exclude中，不存在则直接返回vnode不进行缓存"},{"t":"list_item","d":5,"p":{"lines":[188,189],"index":2},"v":"2. 获取当前组件实例的key，cid +&quot;∶∶&quot;+ tag"},{"t":"list_item","d":5,"p":{"lines":[189,190],"index":3},"v":"3. 缓存对象中是否存在对应key的实例","c":[{"t":"list_item","d":7,"p":{"lines":[190,191],"index":1},"v":"1. 存在直接返回"},{"t":"list_item","d":7,"p":{"lines":[191,192],"index":2},"v":"2. 不存在缓存至缓存对象，再返回"}]},{"t":"list_item","d":5,"p":{"lines":[192,193],"index":4},"v":"4. 判断是否超过最大缓存数量，数量超过了，清除keys数组中对应的第一个缓存"}]}]}]})</script>
</body>
</html>
