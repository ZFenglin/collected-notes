<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"基本概念","c":[{"t":"heading","d":2,"p":{"lines":[2,3]},"v":"MVVM","c":[{"t":"heading","d":3,"p":{"lines":[4,5]},"v":"MVVM和MVC、MVP的区别","c":[{"t":"heading","d":4,"p":{"lines":[6,7]},"v":"MVC","c":[{"t":"ordered_list","d":5,"p":{"lines":[11,15],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[11,12],"index":1},"v":"1. View 负责页面的显示逻辑"},{"t":"list_item","d":6,"p":{"lines":[12,13],"index":2},"v":"2. Model 负责存储页面的业务数据和数据处理操作"},{"t":"list_item","d":6,"p":{"lines":[13,14],"index":3},"v":"3. Controller 层主要负责用户与应用的响应操作"}]},{"t":"ordered_list","d":5,"p":{"lines":[16,19],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[16,17],"index":1},"v":"1. View和Model用观察者模式联系，Model更新会触发View更新"},{"t":"list_item","d":6,"p":{"lines":[17,18],"index":2},"v":"2. 交互产生时Controller触发Model更新，Model再通知View更新"}]}]},{"t":"heading","d":4,"p":{"lines":[19,20]},"v":"MVVM","c":[{"t":"ordered_list","d":5,"p":{"lines":[23,27],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[23,24],"index":1},"v":"1. Model代表数据模型，数据和业务逻辑都在Model层中定义"},{"t":"list_item","d":6,"p":{"lines":[24,25],"index":2},"v":"2. View代表UI视图，负责数据的展示"},{"t":"list_item","d":6,"p":{"lines":[25,26],"index":3},"v":"3. ViewModel负责联系Model和View"}]},{"t":"ordered_list","d":5,"p":{"lines":[28,30],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[28,29],"index":1},"v":"1. ViewModel监听Model数据，控制View更新，或者处理View交互，更新Model数据"}]}]},{"t":"heading","d":4,"p":{"lines":[30,31]},"v":"MVP","c":[{"t":"list_item","d":6,"p":{"lines":[32,33],"index":1},"v":"1. 与 MVC 唯一不同的在于 Presenter 和 Controller"},{"t":"list_item","d":6,"p":{"lines":[33,34],"index":2},"v":"2. Presenter 同时具有Model和View的接口，可以再其中处理View和Model的同步更新"}]}]},{"t":"heading","d":3,"p":{"lines":[35,36]},"v":"MVVM优缺点","c":[{"t":"list_item","d":5,"p":{"lines":[37,38],"index":1},"v":"1. 优点","c":[{"t":"list_item","d":7,"p":{"lines":[38,39],"index":1},"v":"1. 分离视图和模型，降低代码耦合"},{"t":"list_item","d":7,"p":{"lines":[39,40],"index":2},"v":"2. 自动更新DOM，让开发者关注数据操作"},{"t":"list_item","d":7,"p":{"lines":[40,41],"index":3},"v":"3. 提高可测试性"}]},{"t":"list_item","d":5,"p":{"lines":[41,42],"index":2},"v":"2. 缺点","c":[{"t":"list_item","d":7,"p":{"lines":[42,43],"index":1},"v":"1. BUG难调试，无法确定是Model问题还是View问题"},{"t":"list_item","d":7,"p":{"lines":[43,44],"index":2},"v":"2. 大模块的Model也很大，长期持有会造成内存花费"},{"t":"list_item","d":7,"p":{"lines":[44,45],"index":3},"v":"3. 大型图形应用程序，视图状态多，VM的构建和维护成本高"}]}]}]},{"t":"heading","d":2,"p":{"lines":[46,47]},"v":"SPA单页面","c":[{"t":"ordered_list","d":3,"p":{"lines":[48,52],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[48,49],"index":1},"v":"1. 仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS"},{"t":"list_item","d":4,"p":{"lines":[49,50],"index":2},"v":"2. SPA 不会因为用户的操作而进行页面的重新加载或跳转，利用路由机制实现 HTML 内容的变换"},{"t":"list_item","d":4,"p":{"lines":[50,51],"index":3},"v":"3. 页面的切换只是相关组件的切换，仅刷新局部资源"}]},{"t":"heading","d":3,"p":{"lines":[52,53]},"v":"SPA优缺点","c":[{"t":"list_item","d":5,"p":{"lines":[54,55],"index":1},"v":"1. 优点","c":[{"t":"list_item","d":7,"p":{"lines":[55,56],"index":1},"v":"1. 用户体验好，内容改变不需要整个页面重新加载"},{"t":"list_item","d":7,"p":{"lines":[56,57],"index":2},"v":"2. SPA服务器压力小"},{"t":"list_item","d":7,"p":{"lines":[57,58],"index":3},"v":"3. 前后端职责分离，架构清晰"}]},{"t":"list_item","d":5,"p":{"lines":[58,59],"index":2},"v":"2. 缺点","c":[{"t":"list_item","d":7,"p":{"lines":[59,60],"index":1},"v":"1. 初次加载耗时多，首次加载时将 JavaScript、CSS 统一加载，部分页面按需加载"},{"t":"list_item","d":7,"p":{"lines":[60,61],"index":2},"v":"2. 前进后退路由管理，页面切换需要自己建立堆栈管理，不能使用浏览器的前进后退功能"},{"t":"list_item","d":7,"p":{"lines":[61,62],"index":3},"v":"3. SEO难度大，所有的内容都在一个页面中动态替换显示"}]}]},{"t":"heading","d":3,"p":{"lines":[63,64]},"v":"与多页面应用区别","c":[{"t":"heading","d":4,"p":{"lines":[65,66]},"v":"多页面概念","c":[{"t":"list_item","d":6,"p":{"lines":[67,68],"index":1},"v":"1. 多个独立页面的应用"},{"t":"list_item","d":6,"p":{"lines":[68,69],"index":2},"v":"2. 每个页面必须重复加载资源"}]}]}]},{"t":"heading","d":2,"p":{"lines":[72,73]},"v":"Vue相关","c":[{"t":"heading","d":3,"p":{"lines":[74,75]},"v":"Vue的优点","c":[{"t":"list_item","d":5,"p":{"lines":[76,77],"index":1},"v":"1. 轻量级框架"},{"t":"list_item","d":5,"p":{"lines":[77,78],"index":2},"v":"2. 简单易学"},{"t":"list_item","d":5,"p":{"lines":[78,79],"index":3},"v":"3. 双向数据绑定"},{"t":"list_item","d":5,"p":{"lines":[79,80],"index":4},"v":"4. 组件化"},{"t":"list_item","d":5,"p":{"lines":[80,81],"index":5},"v":"5. 视图，数据和结构分离"},{"t":"list_item","d":5,"p":{"lines":[81,82],"index":6},"v":"6. 虚拟DOM"}]},{"t":"heading","d":3,"p":{"lines":[83,84]},"v":"Vue优化","c":[{"t":"heading","d":4,"p":{"lines":[85,86]},"v":"编码阶段","c":[{"t":"list_item","d":6,"p":{"lines":[87,88],"index":1},"v":"1. 减少data中数据，data中数据会进行响应式处理并且会收集对应watcher"},{"t":"list_item","d":6,"p":{"lines":[88,89],"index":2},"v":"2. v-if和v-for不连用"},{"t":"list_item","d":6,"p":{"lines":[89,90],"index":3},"v":"3. v-for的每一项绑定事件使用事件代理"},{"t":"list_item","d":6,"p":{"lines":[90,91],"index":4},"v":"4. 更多情况下使用v-show替代v-if"},{"t":"list_item","d":6,"p":{"lines":[91,92],"index":5},"v":"5. key保证唯一"},{"t":"list_item","d":6,"p":{"lines":[92,93],"index":6},"v":"6. 使用路由懒加载和异步组件"},{"t":"list_item","d":6,"p":{"lines":[93,94],"index":7},"v":"7. 防抖、节流"},{"t":"list_item","d":6,"p":{"lines":[94,95],"index":8},"v":"8. 第三方模块按需导入"}]},{"t":"heading","d":4,"p":{"lines":[96,97]},"v":"打包优化","c":[{"t":"list_item","d":6,"p":{"lines":[98,99],"index":1},"v":"1. 压缩代码"},{"t":"list_item","d":6,"p":{"lines":[99,100],"index":2},"v":"2. Tree Shaking/Scope Hoisting"},{"t":"list_item","d":6,"p":{"lines":[100,101],"index":3},"v":"3. 使用cdn加载第三方模块"},{"t":"list_item","d":6,"p":{"lines":[101,102],"index":4},"v":"4. 多线程打包happypack"},{"t":"list_item","d":6,"p":{"lines":[102,103],"index":5},"v":"5. splitChunks抽离公共文件"},{"t":"list_item","d":6,"p":{"lines":[103,104],"index":6},"v":"6. sourceMap优化"}]},{"t":"heading","d":4,"p":{"lines":[105,106]},"v":"用户体验","c":[{"t":"list_item","d":6,"p":{"lines":[107,108],"index":1},"v":"1. 骨架屏"},{"t":"list_item","d":6,"p":{"lines":[108,109],"index":2},"v":"2. 使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等"},{"t":"list_item","d":6,"p":{"lines":[109,110],"index":3},"v":"3. 图片懒加载v-lazy"},{"t":"list_item","d":6,"p":{"lines":[110,111],"index":4},"v":"4. 长列表滚动到可视区域动态加载"}]},{"t":"heading","d":4,"p":{"lines":[112,113]},"v":"SEO优化","c":[{"t":"list_item","d":6,"p":{"lines":[114,115],"index":1},"v":"1. 预渲染"},{"t":"list_item","d":6,"p":{"lines":[115,116],"index":2},"v":"2. 服务端渲染SSR"}]}]},{"t":"heading","d":3,"p":{"lines":[117,118]},"v":"React和Vue异同","c":[{"t":"heading","d":4,"p":{"lines":[119,120]},"v":"相同点","c":[{"t":"list_item","d":6,"p":{"lines":[121,122],"index":1},"v":"1. 注意力集中在核心库，其他功能如路由和状态管理由其他库处理"},{"t":"list_item","d":6,"p":{"lines":[122,123],"index":2},"v":"2. 都有自己的构建工具，有一个最佳实践设置的项目模板"},{"t":"list_item","d":6,"p":{"lines":[123,124],"index":3},"v":"3. 都使用了Virtual DOM"},{"t":"list_item","d":6,"p":{"lines":[124,125],"index":4},"v":"4. 都有props概念，允许组件间传值"},{"t":"list_item","d":6,"p":{"lines":[125,126],"index":5},"v":"5. 都鼓励组件化应用"}]},{"t":"heading","d":4,"p":{"lines":[127,128]},"v":"不同点","c":[{"t":"heading","d":5,"p":{"lines":[129,130]},"v":"数据流","c":[{"t":"list_item","d":7,"p":{"lines":[131,132],"index":1},"v":"1. Vue支持双向绑定"},{"t":"list_item","d":7,"p":{"lines":[132,133],"index":2},"v":"2. React一直提倡单向数据流"}]},{"t":"heading","d":5,"p":{"lines":[134,135]},"v":"虚拟DOM","c":[{"t":"list_item","d":7,"p":{"lines":[136,137],"index":1},"v":"1. Vue2引入虚拟DOM，同时渲染中会跟踪组件依赖关系，无需重新渲染整个组件"},{"t":"list_item","d":7,"p":{"lines":[137,138],"index":2},"v":"2. React应用状态改变则全部子组件都会重新渲染，可以通过PureComponent/shouldComponentUpdate控制"}]},{"t":"heading","d":5,"p":{"lines":[139,140]},"v":"模板编写","c":[{"t":"ordered_list","d":6,"p":{"lines":[141,144],"start":1},"v":"","c":[{"t":"list_item","d":7,"p":{"lines":[141,142],"index":1},"v":"1. Vue推荐HTML模板编写"},{"t":"list_item","d":7,"p":{"lines":[142,143],"index":2},"v":"2. React推荐使用JSX编写"}]},{"t":"heading","d":6,"p":{"lines":[144,145]},"v":"template和jsx的有什么分别","c":[{"t":"list_item","d":8,"p":{"lines":[146,147],"index":1},"v":"1. 解析方式不同","c":[{"t":"list_item","d":10,"p":{"lines":[147,148],"index":1},"v":"1. template通过vue-loader编译.vue文件，内部依赖的vue-template-compiler模块"},{"t":"list_item","d":10,"p":{"lines":[148,149],"index":2},"v":"2. jsx使用babel-plugin-transform-vue-jsx"}]},{"t":"list_item","d":8,"p":{"lines":[149,150],"index":2},"v":"2. 但是都是render的表现形式","c":[{"t":"list_item","d":10,"p":{"lines":[150,151],"index":1},"v":"1. JSX更灵活，复杂组件更具优势"},{"t":"list_item","d":10,"p":{"lines":[151,152],"index":2},"v":"2. template虽然呆滞，但是更符合视图和逻辑分离习惯，更直观"}]}]}]},{"t":"heading","d":5,"p":{"lines":[153,154]},"v":"数据监听","c":[{"t":"list_item","d":7,"p":{"lines":[155,156],"index":1},"v":"1. Vue认为数据可变，Vue通过对getter和setter的劫持，精确知道数据变化"},{"t":"list_item","d":7,"p":{"lines":[156,157],"index":2},"v":"2. React强调数据不可变，React通过比较引用方式，不优化则会有大量不必要的DOM重新渲染"}]},{"t":"heading","d":5,"p":{"lines":[158,159]},"v":"高阶组件","c":[{"t":"list_item","d":7,"p":{"lines":[160,161],"index":1},"v":"1. Vue通过mixins对组件进行扩展，Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译无法使用HOC"},{"t":"list_item","d":7,"p":{"lines":[161,162],"index":2},"v":"2. React可以通过高阶组件（HOC）扩展，高阶组件就是高阶函数，而React的组件本身就是纯粹的函数"}]},{"t":"heading","d":5,"p":{"lines":[165,166]},"v":"构建工具","c":[{"t":"list_item","d":7,"p":{"lines":[167,168],"index":1},"v":"1. React =&gt; Create React APP"},{"t":"list_item","d":7,"p":{"lines":[168,169],"index":2},"v":"2. Vue =&gt; vue-cli（但是vue3更推荐使用"}]},{"t":"heading","d":5,"p":{"lines":[170,171]},"v":"跨平台","c":[{"t":"list_item","d":7,"p":{"lines":[172,173],"index":1},"v":"1. React =&gt; React Native"},{"t":"list_item","d":7,"p":{"lines":[173,174],"index":2},"v":"2. Vue =&gt; Weex"}]}]},{"t":"heading","d":4,"p":{"lines":[175,176]},"v":"处理性能瓶颈","c":[{"t":"heading","d":5,"p":{"lines":[177,178]},"v":"问题产生","c":[{"t":"list_item","d":7,"p":{"lines":[179,180],"index":1},"v":"1. Vue问题","c":[{"t":"list_item","d":9,"p":{"lines":[180,181],"index":1},"v":"1. Vue核心就是“响应式”"},{"t":"list_item","d":9,"p":{"lines":[181,182],"index":2},"v":"2. 也就是数据变化后，会主动通知我们，响应式数据新建 Watcher 监听，本身就比较损耗性能"},{"t":"list_item","d":9,"p":{"lines":[182,183],"index":3},"v":"3. 项目大了之后每个数据都有一个 watcher 会影响性能"}]},{"t":"list_item","d":7,"p":{"lines":[183,184],"index":2},"v":"2. React问题","c":[{"t":"list_item","d":9,"p":{"lines":[184,185],"index":1},"v":"1. React 的虚拟 DOM 的 Diff 计算逻辑来说，如果虚拟 DOM 树过于庞大，使得计算时间大于 16.6ms，那么就可能会造成性能的卡顿"}]}]},{"t":"heading","d":5,"p":{"lines":[186,187]},"v":"处理方式","c":[{"t":"ordered_list","d":6,"p":{"lines":[190,194],"start":1},"v":"","c":[{"t":"list_item","d":7,"p":{"lines":[190,191],"index":1},"v":"1. React 为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了 Fiber 架构"},{"t":"list_item","d":7,"p":{"lines":[191,192],"index":2},"v":"2. 就是把整个虚拟 DOM 树微观化，变成链表，然后我们利用浏览器的空闲时间计算 Diff"},{"t":"list_item","d":7,"p":{"lines":[192,193],"index":3},"v":"3. 浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲"}]},{"t":"ordered_list","d":6,"p":{"lines":[196,200],"start":1},"v":"","c":[{"t":"list_item","d":7,"p":{"lines":[196,197],"index":1},"v":"1. 对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新"},{"t":"list_item","d":7,"p":{"lines":[197,198],"index":2},"v":"2. 组件内部的数据变化，则通过虚拟 DOM 去更新页面"},{"t":"list_item","d":7,"p":{"lines":[198,199],"index":3},"v":"3. 响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小"}]},{"t":"heading","d":6,"p":{"lines":[202,203]},"v":"Vue 需不需要 React 的 Fiber？","c":[{"t":"list_item","d":8,"p":{"lines":[204,205],"index":1},"v":"1. Vue将虚拟DOM控制在了组件级，不会出现长时间计算Diff的问题"},{"t":"list_item","d":8,"p":{"lines":[205,206],"index":2},"v":"2. Vue3虚拟Dom的静态标记和自动缓存功能，让静态的节点和属性可以直接绕过Diff逻辑，也大大减少了虚拟Dom的Diff事件"},{"t":"list_item","d":8,"p":{"lines":[206,207],"index":3},"v":"3. 时间切片也会带来额外的系统复杂性，投入与产出不理想"}]}]}]}]}]},{"t":"heading","d":2,"p":{"lines":[208,209]},"v":"其它","c":[{"t":"heading","d":3,"p":{"lines":[210,211]},"v":"SSR","c":[{"t":"heading","d":4,"p":{"lines":[212,213]},"v":"服务端渲染","c":[{"t":"list_item","d":6,"p":{"lines":[214,215],"index":1},"v":"1. 更好的SEO"},{"t":"list_item","d":6,"p":{"lines":[215,216],"index":2},"v":"2. 首屏加载速度更快"}]},{"t":"heading","d":4,"p":{"lines":[217,218]},"v":"开发受限","c":[{"t":"list_item","d":6,"p":{"lines":[219,220],"index":1},"v":"1. 服务端只支持beforeCreate和created两个钩子"},{"t":"list_item","d":6,"p":{"lines":[220,221],"index":2},"v":"2. 外部扩展库时有的需要特殊处理"}]}]},{"t":"heading","d":3,"p":{"lines":[224,225]},"v":"assets和static","c":[{"t":"list_item","d":5,"p":{"lines":[226,227],"index":1},"v":"1. 相同点则是都用于存放静态资源"},{"t":"list_item","d":5,"p":{"lines":[227,228],"index":2},"v":"2. assets，其中的静态资源文件在打包时，会对资源进行体积压缩和代码格式化"},{"t":"list_item","d":5,"p":{"lines":[228,229],"index":3},"v":"3. static，打包不会走压缩和格式化流程"},{"t":"list_item","d":5,"p":{"lines":[229,230],"index":4},"v":"4. 推荐自定义的静态资源放assets，第三方资源由于处理了，放static减少打包时间"}]}]}]})</script>
</body>
</html>
