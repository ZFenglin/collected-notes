# 处理入口

vue的_init结尾触发vm.$mount(vm.$options.el)，开始进行模板编译和元素挂载

Vue.prototype.$mount处理元素的创建和挂载

同时vue将其拆分成两个
1. 负责组件render函数获取的各个平台公共的mount
2. 负责执行元素创建和挂载的web平台独有的mount

## 执行过程

template =(parse)=> AST =(generate)=> render函数 =(createElement)=> vnode =(patch)=> 真实元素

## web平台独有的mount

位于src/platforms/web/entry-runtime-with-compiler.js

只处理web下的情形，主要是为了获取到render函数和绑定元素，最后执行公共的mount

1. 获取当前元素
2. render函数获取
   1. template模板获取
   2. 通过模板获取render
3. 执行公共mount

```JS
// 公共mount备份
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function(el, hydrating) {
    // 获取当前元素
    el = el && query(el)
    // 对于body和documentElement直接返回
    if (el === document.body || el === document.documentElement) {
        return this
    }
    // render函数获取
    const options = this.$options
    if (!options.render) {
        // 模板获取
        let template = options.template
        if (template) {
            if (typeof template === 'string') {
                if (template.charAt(0) === '#') {
                    template = idToTemplate(template)
                }
            } else if (template.nodeType) {
                template = template.innerHTML
            } else {
                return this
            }
        } else if (el) {
            template = getOuterHTML(el)
        }
        // 通过模板获取render
        if (template) {
            const {
                render,
                staticRenderFns
            } = compileToFunctions(template, {
                outputSourceRange: process.env.NODE_ENV !== 'production',
                shouldDecodeNewlines,
                shouldDecodeNewlinesForHref,
                delimiters: options.delimiters,
                comments: options.comments
            }, this)
            options.render = render
            options.staticRenderFns = staticRenderFns
        }
    }
    // 执行公共mount
    return mount.call(this, el, hydrating)
}
```

### render、template和el优先级

从Vue.prototype.$mount中获取render方式可以知道，组件渲染配置优先级上render > template > el

## 各个平台公共的mount

位于src/platforms/web/runtime/index.js

公共的$mount方法，会在各个平台下重写

```JS
// 设置__patch__
Vue.prototype.__patch__ = inBrowser ? patch : noop

// 公共的mount方法
Vue.prototype.$mount = function(el, hydrating) {
    // 获取元素
    el = el && inBrowser ? query(el) : undefined
    // 组件挂载
    return mountComponent(this, el, hydrating)
}
```

### mountComponent

1. 没有render则渲染空节点
2. 创建updateComponent负责组件首次渲染和后续更新
3. 创建组件渲染Watcher，即一个vue的实例只有一个渲染watcher

```JS
export function mountComponent(vm, el, hydrating) {
    vm.$el = el
    // 没有render则渲染空节点
    if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode
    }
    callHook(vm, 'beforeMount')
    // updateComponent负责组件首次渲染和后续更新
    let updateComponent
    updateComponent = () => {
        vm._update(vm._render(), hydrating)
    }
    // 创建组件渲染Watcher，即一个vue的实例只有一个渲染watcher
    new Watcher(vm, updateComponent, noop, {
        before() {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook(vm, 'beforeUpdate')
            }
        }
    }, true /* isRenderWatcher */ )
    // 非服务端渲染
    hydrating = false
    if (vm.$vnode == null) {
        vm._isMounted = true
        callHook(vm, 'mounted')
    }
    return vm
}
```

updateComponent中调用了在构造函数时添加的_render和_update

```JS
updateComponent = () => {
    vm._update(vm._render(), hydrating)
}
```

这个方法就是Vue处理模板编译，更新和挂载的核心

_render位于renderMixin，负责将生成的render执行获取vnode

_update位于lifecycleMixin，负责执行__patch__方法，将vnode执行挂载
