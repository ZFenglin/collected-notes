# 编译与挂载

## 渲染过程

1. 编译过程（外层mount）：template =(parse)=> AST =(optimize)=> 静态节点处理过的AST =(generate)=> 获取render
2. 挂载过程（内部mount）：执行_render =(createElement)=> vnode => 执行_update =(patch)=> 真实元素

### 模板编译原理

1. 模板编译的入口是compileToFunctions，是由createCompilerCreator返回的方法，目的是将template转化为render函数
2. 原理见[Vue/Code/编译与挂载/模板编译入口](../Code/03-编译与挂载/02-模板编译入口.md)

```js
compileToFunctions(template, options //省略}, this)
```

#### 三个阶段

1. 解析阶段
2. 优化阶段
3. 生成阶段

#### 解析阶段

利用正则解析template字符串，将标签指令等转化为AST

```js
const ast = parse(template.trim(), options)
```

##### 解析过程

1. 正则解析模板
2. 解析到开始闭合标签，分别执行对应的回调函数

##### AST类型

1. 1为普通元素
2. 2为表达式
3. 3为纯文本

#### 优化阶段

1. 遍历AST
   1. 第一遍markStatic找到其中一些静态节点并标记
   2. 第二遍markStaticRoots找到静态根节点
2. 下次diff时直接跳过，优化渲染性能

```js
optimize(ast, options)
```

#### 生成阶段

1. 将最终的AST转化为render函数字符串
2. 通过 new Function(编译代码字符串) 生成render函数

```js
const code = generate(ast, options)
```

## 虚拟DOM

Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构

### 虚拟DOM的优点

1. 配合不同渲染工具使跨平台成为可能
2. 可以将多次DOM修改处理好后一次性更新到页面
   1. 减少页面渲染次数
   2. 减少DOM重排重绘
3. 无需手动操作DOM
   1. 手动操作无法保证程序性能
   2. 提升开发效率

### 虚拟DOM解析过程

1. 将要插入到文档额DOM树结构进行分析，使用js对象表示
2. 页面改变，构建新树并和老树进行比较得出差异
3. 将差异应用到真正的DOM中，从而更新视图

### 使用虚拟DOM的原因

1. 浏览器渲染流程：解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler
2. 只是保证性能下限，在不手动优化的情况下，性能还可以
   1. 真实DOM∶ 生成HTML字符串＋重建所有的DOM元素
   2. 虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新
   3. 虽然虚拟DOM在更新页面前，计算不同会消耗更多时间，但是这个性能消耗对比DOM操作就少很多
3. 生成结果时JS对象，可以很方便进行跨平台

### 虚拟DOM性能真高于真实DOM吗

1. 首次渲染大量DOM，由于多一层虚拟DOM的计算，会慢于直接innerHTML直接插入
2. 真实DOM针对性优化下，速度还是快于虚拟DOM
3. 还是那么一句话虚拟DOM只是保证性能下限，在不手动优化的情况下，性能还可以

### DIFF原理

1. Diff只对同级节点比较
2. 原理见[Vue/Code/编译与挂载/元素patch处理](../Code/03-编译与挂载/07-元素patch处理.md)
   1. patchVnode
      1. 比对节点本身，不同直接替换
      2. 本身节点相同，patchVnode处理，当存在子节点
         1. 新无旧有，移除所有子节点
         2. 新有旧无，添加新节点
         3. 都有，updateChildren比较（diff核心）
   2. updateChildren
      1. 旧节点为空处理
      2. 头头相同，头节点后移
      3. 尾尾相同，尾节点前移
      4. 头尾相同，右移，旧头节点移动至旧尾节点后，头节点后移，尾节点前移
      5. 尾头相同，左移，旧尾节点移动至旧头节点前，头节点后移，尾节点前移
      6. 乱序处理
         1. 获取旧节点映射oldKeyToIdx
         2. 获取映射中与新头节点key相同的值
         3. 是否存在映射的值
            1. 不存在直接创建节点，并插到旧头节点之前
            2. 存在，则获取节点，看节点是否相同分别处理
         4. 新头节点index后移
      7. 剩余节点处理
          1. 新节点剩余，添加新节点
          2. 旧节点剩余，删除旧节

### 节点key的作用

#### v-if 中使用 key

1. 当元素有类型相同的元素时，vue会进行复用
2. 当key值相同或者未设置时，这些元素自带的值不会丢失，例如input用户输入不会清除
3. 此时修改或添加key可以使元素不会被复用

#### v-for 中使用 key

1. v-for渲染的列表，默认采用就地复用的策略，即列表数据顺序变化了，vue不是移动DOM，而是本地直接复用
2. 提供key值，帮助vue追踪元素，用移动取代复用

#### 使用key的优势

1. 更准确：存在key，vue不会就地复用，而是改用移动节点
2. 更快速：key的唯一性生成MAP来获取对应节点，速度比便利快

#### index不可以作为key

1. 应为数组的index与项无关，和没写没区别
2. 依然会执行默认的原地复用

## slot

插槽，Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口

### slot分类

1. 默认插槽：solt没有name属性时的默认显示插槽，其实名称为default，只能有一个
2. 具名插槽：具有name属性的插槽，一个组件可以有多个
3. 作用域插槽：插槽内部可以获取子组件数据，父组件根据子组件数据决定子组件插槽如何渲染

### slot原理

1. 子组件实例化时，会获取父组件传入的slot标签内容，并存放在vm.$slot中
   1. 默认插槽为vm.$slot.default
   2. 具名插槽为vm.$slot.xxx
2. 组件渲染时，遇到slot标签，使用$slot中的内容进行替换，可以在插件处理时传入当前数据，此时就是作用域插槽

## keep-alive

1. vue自带的组件，利用最近最少使用算法LRU处理缓存，提高页面访问速度
2. 被缓存的页面增加deactivated与activated生命周期
   1. 可以在activated判断路由参数和请求参数是否变更，决定是否更新页面数据

### keep-alive属性

1. include：字符串或正则表达式，只有名称匹配的组件会被匹配
2. exclude：字符串或正则表达式，任何名称匹配的组件都不会被缓存
3. max：最多可以缓存多少组件实例

### LRU （least recently used）

从内存中找出最久未使用的数据并置换新的数据

1. 新数据插入到链表头部
2. 命中缓存时，将数据移动至链表头部
3. 链表满时，先丢弃尾部的数据

### 实现方式

1. 判断当前组件的name，不在include和在exclude中，不存在则直接返回vnode不进行缓存
2. 获取当前组件实例的key，cid +"∶∶"+ tag
3. 缓存对象中是否存在对应key的实例
   1. 存在直接返回
   2. 不存在缓存至缓存对象，再返回
4. 判断是否超过最大缓存数量，数量超过了，清除keys数组中对应的第一个缓存
