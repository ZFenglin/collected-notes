# 面试题

## 前端路由理解

出现的前提
1. AJAX出现，允许不刷新浏览器的情况下更新页面，促使SPA出现
2. SPA存在问题
   1. 不会记住用户操作
   2. SEO不友好

此时出现了两个问题
1. SPA无法记住用户操作问题
2. 用户刷新页面如何不重复加载资源（服务端已经无法解决）

前端路由因此出现，解决思路如下
1. 前端拦截用户刷新
2. 感知URL变化，渲染不同页面

## hash和history模式区别

### hash模式

hash模式是开发中默认的模式，它的URL带着一个#

#### hash模式优势

1. hash值会出现在URL中，但是不会在HTTP请求中，浏览器的前进后退不会请求服务器
2. hash值的改动不会重新加载页面
3. 浏览器支持度好

#### hash的监听

监听浏览器的onhashchange事件

### history模式

传统路由分发模式，用户在输入一个URL时，服务器会接收这个请求，并解析这个URL

#### history模式特点

1. 没有#更美观
2. 需要后台支持，没有配置正确则会返回404

### hash和history更改URL

#### 相关浏览器API

修改历史状态，但是页面不会刷新
1. pushState()
2. replaceState()

切换历史状态
1. forward()
2. back()
3. go()

#### 两者跳转处理比较

首先说明两者都使用的跳转工具方法pushState

```JS
export function pushState(url, replace) {
    saveScrollPosition()
    const history = window.history
    try {
        if (replace) {
            const stateCopy = extend({}, history.state)
            stateCopy.key = getStateKey()
            history.replaceState(stateCopy, '', url)
        } else {
            history.pushState({
                key: setStateKey(genStateKey())
            }, '', url)
        }
    } catch (e) {
        window.location[replace ? 'replace' : 'assign'](url)
    }
}
```

##### hash

hash利用pushHash处理url更改
1. 优先pushState
2. 不支持则window.location.hash直接修改

```JS
function pushHash(path) {
    if (supportsPushState) {
        pushState(getUrl(path))
    } else {
        window.location.hash = path
    }
}
```

##### history

history则直接使用pushState

```JS
pushState(cleanPath(this.base + route.fullPath))
```

##### 修改方式比较

无论哪种方式，修改地址只有history.pushState()和直接修改window.location.hash两种方式

history.pushState()
1. 设置的新 URL 可以是与当前 URL 同源的任意 URL
2. 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中
3. 通过 stateObject 参数可以添加任意类型的数据到记录中
4. 前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误
5. 可额外设置 title 属性供后续使用

直接修改window.location.hash
1. 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL
2. hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中
3. hash 只可添加短字符串
4. 仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误

## 动态路由

将定匹配模式的路由映射到同一个组件

```JS
const routes = [
    // 动态字段以冒号开始
    {
        path: '/users/:id',
        component: User
    },
]
```

其匹配的规则如下

```
匹配模式
/users/:username/posts/:postId

匹配路径
/users/eduardo/posts/123

$route.params
{ username: 'eduardo', postId: '123' }
```

由于支持正则，当然也可用用于404页面匹配

```JS
const routes = [
    // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下
    {
        path: '/:pathMatch(.*)*',
        name: 'NotFound',
        component: NotFound
    },
    // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下
    {
        path: '/user-:afterUser(.*)',
        component: UserGeneric
    },
]
```

## 路由跳转方式

### param方式

不会对路径进行修改

并且需要命名的路由，让路由建立 url（即声明路由时需要name属性）

#### 路由跳转

声明式

```HTML
<router-link :to="{ name: 'user', params: { username: 'eduardo' }}" />
```

编程式

```JS
this.$router.push({
    name: 'user',
    params: {
        username: 'eduardo'
    }
})
```

#### 参数获取

```JS
this.$route.params.username
```

### query方式

会修改路径，形如/user?username=eduardo

#### 路由跳转

标签点击

```HTML
<router-link :to="{ name: '/user', query: { username: 'eduardo' }}">
```

JS处理

```JS
this.$router.push({
    name: '/user',
    query: {
        username: 'eduardo'
    }
})

this.$router.push('/user?username=' + 'eduardo')
```

#### 参数获取

```JS
this.$route.query.username
```

### params和query的区别

用法
1. params要用name来引入
2. query要用path来引入

url地址显示
1. params则类似于post
2. query更加类似于ajax中get传参

刷新数据丢失
1. params刷新会丢失params里面的数据
2. query刷新不会丢失query里面的数据

## 路由守卫

### 植入守卫方式

#### 全局前置/钩子

1. router.beforeEach：全局前置守卫
2. router.beforeResolve：全局解析守卫，beforeRouteEnter调用后调用
3. router.afterEach：全局后置钩子

#### 路由独享的守卫

配置路由时添加

只有beforeEnter，有三个参数∶ to、from、next

#### 组件内的守卫

1. beforeRouteEnter：进入组件前触发，访问不到this，因为该守卫执行前组件实例还没有被创建，传一个回调给 next来访问
2. beforeRouteUpdate：当前地址改变并且组件被复用时触发，/foo/1 和 /foo/2 之间跳转时会触发
3. beforeRouteLeave：离开组件被调用

### 守卫执行流程

假设是从a组件离开，第一次进入b组件

#### 解析b组件前

1. 触发进入其他路由
2. beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开
3. beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等
4. beforeRouteUpdate：在重用的组件里调用（2.2+）
5. beforeEnter：路由独享守卫

此时b组件准备开始解析

#### 解析b组件

1. 解析异步路由组件
2. beforeRouteEnter：路由组件的组件进入路由前钩子
3. beforeResolve：路由全局解析守卫（2.5+），标示解析阶段完成，此时导航被确认
4. afterEach：路由后置全局钩子

#### b组件生命周期

1. 非重用组件，开始组件实例的生命周期：beforeCreate、created、beforeMount、（此处开始执行a的beforeDestroy和destroyed）、mounted
2. 触发 DOM 更新
3. 用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数
4. 导航完成

## 其它

### 路由懒加载

箭头函数+import动态加载

```JS
() => import('@/components/list.vue')
```

箭头函数+require动态加载

```JS
resolve => require(['@/components/list'], resolve)
```

使用webpack的require.ensure技术，多个路由指定相同的chunkName则会打包到一个js文件中

```JS
r => require.ensure([], () => r(require('@/components/list')), 'list')
```

### 如何获取页面hash变化

1. watch深度监听$route的变化
2. window.location.hash读取#值

### $route 和$router 的区别

1. $route：路由信息对象具有path，params，hash，query，fullPath，matched，name 等路由信息参数
2. $router：路由实例，包括了路由的跳转方法，钩子函数等

### Vue-router跳转和location.href区别

1. location.href= /url会造成页面刷新
2. history.pushState( /url )，仅改变URL，不刷新页面，vue-router使用的方式
