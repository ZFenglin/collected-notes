<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"Function","c":[{"t":"heading","d":2,"p":{"lines":[2,3]},"v":"概念","c":[{"t":"heading","d":3,"p":{"lines":[4,5]},"v":"函数是一等公民","c":[{"t":"list_item","d":5,"p":{"lines":[7,8],"index":1},"v":"1. 可以存储在变量中"},{"t":"list_item","d":5,"p":{"lines":[8,9],"index":2},"v":"2. 可以作为参数"},{"t":"list_item","d":5,"p":{"lines":[9,10],"index":3},"v":"3. 可以作为返回值"}]},{"t":"heading","d":3,"p":{"lines":[13,14]},"v":"函数声明方式","c":[{"t":"list_item","d":5,"p":{"lines":[15,16],"index":1},"v":"1. function fn() {}：函数提升，提升的同时会进行赋值"},{"t":"list_item","d":5,"p":{"lines":[16,17],"index":2},"v":"2. var fn = function () {}：变量提升，var声明只会初始化为undefined，let和const则是不会初始化"}]}]},{"t":"heading","d":2,"p":{"lines":[18,19]},"v":"<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>","c":[{"t":"heading","d":3,"p":{"lines":[22,23]},"v":"箭头函数特点","c":[{"t":"list_item","d":5,"p":{"lines":[24,25],"index":1},"v":"1. 都是匿名函数，设计时就认定为一种更加纯粹的函数"},{"t":"list_item","d":5,"p":{"lines":[25,26],"index":2},"v":"2. 没有属于自己的arguments、super、new.target"},{"t":"list_item","d":5,"p":{"lines":[26,27],"index":3},"v":"3. 不可以作为generator函数使用"},{"t":"list_item","d":5,"p":{"lines":[27,28],"index":4},"v":"4. 箭头函数内部使用this时看上去更像闭包，Babel的编译结果就是闭包处理"},{"t":"list_item","d":5,"p":{"lines":[28,29],"index":5},"v":"5. 箭头函数内部没有自己this"},{"t":"list_item","d":5,"p":{"lines":[29,30],"index":6},"v":"6. 没有自己的显示原型prototype"},{"t":"list_item","d":5,"p":{"lines":[30,31],"index":7},"v":"7. 箭头函数不能使用new"},{"t":"list_item","d":5,"p":{"lines":[31,32],"index":8},"v":"8. 不能用call/apply/bind去改变this指向只能传递参数"}]},{"t":"heading","d":3,"p":{"lines":[33,34]},"v":"箭头函数可以使用Function方法的原因","c":[{"t":"list_item","d":5,"p":{"lines":[35,36],"index":1},"v":"1. 箭头函数的<strong>protp</strong>等价于Function.prototype"},{"t":"list_item","d":5,"p":{"lines":[36,37],"index":2},"v":"2. 方法的Function.prototype具有函数的方法"}]}]},{"t":"heading","d":2,"p":{"lines":[38,39]},"v":"严格模式（use strict）","c":[{"t":"heading","d":3,"p":{"lines":[42,43]},"v":"严格模式目的","c":[{"t":"list_item","d":5,"p":{"lines":[44,45],"index":1},"v":"1. 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为"},{"t":"list_item","d":5,"p":{"lines":[45,46],"index":2},"v":"2. 消除代码运行的不安全之处，保证代码运行的安全"},{"t":"list_item","d":5,"p":{"lines":[46,47],"index":3},"v":"3. 提高编译器效率，增加运行速度"},{"t":"list_item","d":5,"p":{"lines":[47,48],"index":4},"v":"4. 为未来新版本的 Javascript 做好铺垫"}]},{"t":"heading","d":3,"p":{"lines":[49,50]},"v":"严格模式区别","c":[{"t":"list_item","d":5,"p":{"lines":[51,52],"index":1},"v":"1. 禁止使用 with 语句"},{"t":"list_item","d":5,"p":{"lines":[52,53],"index":2},"v":"2. 禁止 this 关键字指向全局对象"},{"t":"list_item","d":5,"p":{"lines":[53,54],"index":3},"v":"3. 对象不能有重名的属性"}]},{"t":"heading","d":3,"p":{"lines":[55,56]},"v":"尾调用","c":[{"t":"ordered_list","d":4,"p":{"lines":[57,60],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[57,58],"index":1},"v":"1. 函数在执行栈中运行，函数a中调用函数b，则保留a的上下并创建b的上下文插入栈中"},{"t":"list_item","d":5,"p":{"lines":[58,59],"index":2},"v":"2. 尾调用就是在函数执行的结尾调用另一个函数"}]},{"t":"heading","d":4,"p":{"lines":[60,61]},"v":"尾调用优化","c":[{"t":"list_item","d":6,"p":{"lines":[62,63],"index":1},"v":"1. 严格模式可以开启"},{"t":"list_item","d":6,"p":{"lines":[63,64],"index":2},"v":"2. 当函数尾调用时，则调用函数的上下文不会保留，可以节省内存"}]}]}]},{"t":"heading","d":2,"p":{"lines":[65,66]},"v":"函数式编程","c":[{"t":"heading","d":3,"p":{"lines":[67,68]},"v":"相关概念","c":[{"t":"heading","d":4,"p":{"lines":[69,70]},"v":"使用函数式编程的原因","c":[{"t":"list_item","d":6,"p":{"lines":[71,72],"index":1},"v":"1. 随React的流行越受到关注，并且vue3开始拥抱函数式编程"},{"t":"list_item","d":6,"p":{"lines":[72,73],"index":2},"v":"2. 可以抛弃this"},{"t":"list_item","d":6,"p":{"lines":[73,74],"index":3},"v":"3. 打包过程中更好利用tree sharking"},{"t":"list_item","d":6,"p":{"lines":[74,75],"index":4},"v":"4. 测试和并行处理方便"},{"t":"list_item","d":6,"p":{"lines":[75,76],"index":5},"v":"5. 很多库方便函数式开发"}]},{"t":"heading","d":4,"p":{"lines":[77,78]},"v":"目前有哪些编程范式","c":[{"t":"list_item","d":6,"p":{"lines":[79,80],"index":1},"v":"1. 面向过程：按照步骤实现"},{"t":"list_item","d":6,"p":{"lines":[80,81],"index":2},"v":"2. 面向对象：事物抽象为类和对象，通过封装，继承，多态演示联系"},{"t":"list_item","d":6,"p":{"lines":[81,82],"index":3},"v":"3. 函数式：事物之间的联系抽象到编程，函数式的函数不是程序中的函数方法，是数学的映射关系，相同输入得到相同输出"}]},{"t":"heading","d":4,"p":{"lines":[83,84]},"v":"高阶函数","c":[{"t":"list_item","d":6,"p":{"lines":[85,86],"index":1},"v":"1. 函数作为参数，并且函数作为返回结果的函数"},{"t":"list_item","d":6,"p":{"lines":[86,87],"index":2},"v":"2. 帮助我们屏蔽细节，抽象通用的问题"},{"t":"list_item","d":6,"p":{"lines":[87,88],"index":3},"v":"3. 使用灵活"}]},{"t":"heading","d":4,"p":{"lines":[89,90]},"v":"<a href=\"https://cloud.tencent.com/developer/article/1857193?from=article.detail.1629653\">纯函数</a>","c":[{"t":"ordered_list","d":5,"p":{"lines":[91,94],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[91,92],"index":1},"v":"1. 纯函数就是相同输入永远会得到相同输出"},{"t":"list_item","d":6,"p":{"lines":[92,93],"index":2},"v":"2. 并且没有可以观察的副作用"}]},{"t":"heading","d":5,"p":{"lines":[96,97]},"v":"纯函数优势","c":[{"t":"list_item","d":7,"p":{"lines":[98,99],"index":1},"v":"1. 可缓存，由于结果相同，可以将纯函数的结果缓存（lodash的memoize）"},{"t":"list_item","d":7,"p":{"lines":[99,100],"index":2},"v":"2. 可测试"},{"t":"list_item","d":7,"p":{"lines":[100,101],"index":3},"v":"3. 并行处理，多线程操作共享内存数据会出现意外，纯函数不会访问共享数据"}]},{"t":"heading","d":5,"p":{"lines":[102,103]},"v":"纯函数副作用","c":[{"t":"list_item","d":7,"p":{"lines":[104,105],"index":1},"v":"1. 函数依赖外部状态，无法保证输出相同则会有副作用"},{"t":"list_item","d":7,"p":{"lines":[105,106],"index":2},"v":"2. 纯函数存在硬编码问题"}]}]},{"t":"heading","d":4,"p":{"lines":[107,108]},"v":"闭包和柯里化"}]},{"t":"heading","d":3,"p":{"lines":[111,112]},"v":"函数组合","c":[{"t":"ordered_list","d":4,"p":{"lines":[113,117],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[113,114],"index":1},"v":"1. 使用纯函数和柯里化很容易写出洋葱代码，即一层包一层的代码"},{"t":"list_item","d":5,"p":{"lines":[114,115],"index":2},"v":"2. 函数组合则是将多个细粒度函数组成一个新函数"},{"t":"list_item","d":5,"p":{"lines":[115,116],"index":3},"v":"3. 函数组合具有结合律，即多个函数组合，只要组合顺序不变，如何组合结果都一样，c(c(x, y), z) 等价于 c(x, c(y, z))"}]},{"t":"heading","d":4,"p":{"lines":[119,120]},"v":"函数组合原理","c":[{"t":"ordered_list","d":5,"p":{"lines":[121,125],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[121,122],"index":1},"v":"1. 将一个复杂函数拆分成多个简单函数"},{"t":"list_item","d":6,"p":{"lines":[122,123],"index":2},"v":"2. 每个方法的结果就是下一个函数的结果"},{"t":"list_item","d":6,"p":{"lines":[123,124],"index":3},"v":"3. 然后使用组合函数将传入函数组合"}]},{"t":"fence","d":5,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">(...args) =&gt; value =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), value)\n</code></pre>\n"}]}]},{"t":"heading","d":3,"p":{"lines":[129,130]},"v":"<a href=\"https://segmentfault.com/a/1190000023744960\">函子</a>","c":[{"t":"heading","d":4,"p":{"lines":[131,132]},"v":"函子概念","c":[{"t":"ordered_list","d":5,"p":{"lines":[133,137],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[133,134],"index":1},"v":"1. 容器：包含值和值的变形关系(这个变形关系就是函数)"},{"t":"list_item","d":6,"p":{"lines":[134,135],"index":2},"v":"2. 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map方法可以运行一个函数对值进行处理(变形关系)"},{"t":"list_item","d":6,"p":{"lines":[135,136],"index":3},"v":"3. 使用函子需要避免外部使用new"}]},{"t":"fence","d":5,"v":"<pre class=\"language-JS\"><code class=\"language-JS\">class Container {\n    //使用类的静态方法，of替代了new Container的作用\n    static of (value) {\n        return new Container(value)\n    }\n    constructor(value) {\n        this._value = value\n    }\n    map(fn) {\n        return Container.of(fn(this._value))\n    }\n}\nconst r = Container.of(5)\n    .map(x =&gt; x + 2) // 7\n    .map(x =&gt; x ** 2) // 49\nconsole.log(r) // Container { _value: 49 }\n</code></pre>\n"}]}]}]}]})</script>
</body>
</html>
