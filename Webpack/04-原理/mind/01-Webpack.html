<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"Webpack","c":[{"t":"heading","d":2,"p":{"lines":[2,3]},"v":"事件流","c":[{"t":"list_item","d":4,"p":{"lines":[4,5],"index":1},"v":"1. webpack类似一个生产线"},{"t":"list_item","d":4,"p":{"lines":[5,6],"index":2},"v":"2. 经过一系列的处理流程后才能将源文件转化成输出结果"},{"t":"list_item","d":4,"p":{"lines":[6,7],"index":3},"v":"3. 只有当前的处理完成后才能提交到下一个流程处理"},{"t":"list_item","d":4,"p":{"lines":[7,8],"index":4},"v":"4. 插件类似插入生产线的某个功能，特定时机对线上资源进行处理"}]},{"t":"heading","d":2,"p":{"lines":[9,10]},"v":"核心概念","c":[{"t":"heading","d":3,"p":{"lines":[11,12]},"v":"Entry：入口"},{"t":"heading","d":3,"p":{"lines":[15,16]},"v":"Moudle：模块"},{"t":"heading","d":3,"p":{"lines":[19,20]},"v":"Chunk：代码块"},{"t":"heading","d":3,"p":{"lines":[23,24]},"v":"Loader：模块转换器"},{"t":"heading","d":3,"p":{"lines":[27,28]},"v":"Plugin：扩展插件"},{"t":"heading","d":3,"p":{"lines":[31,32]},"v":"Output：输出结果"}]},{"t":"heading","d":2,"p":{"lines":[35,36]},"v":"相关类","c":[{"t":"heading","d":3,"p":{"lines":[37,38]},"v":"Tapable","c":[{"t":"list_item","d":5,"p":{"lines":[39,40],"index":1},"v":"1. Webpack通过Tapable组织生产线"},{"t":"list_item","d":5,"p":{"lines":[40,41],"index":2},"v":"2. 插件只需要监听它所关心的事件，就能加入到生产线中"},{"t":"list_item","d":5,"p":{"lines":[41,42],"index":3},"v":"3. 保持了插件的有序性"}]},{"t":"heading","d":3,"p":{"lines":[43,44]},"v":"Complier","c":[{"t":"list_item","d":5,"p":{"lines":[45,46],"index":1},"v":"1. Complier负责整个的构建流程（准备、编译、输出等）"},{"t":"list_item","d":5,"p":{"lines":[46,47],"index":2},"v":"2. 文件监听"},{"t":"list_item","d":5,"p":{"lines":[47,48],"index":3},"v":"3. 启动编译"}]},{"t":"heading","d":3,"p":{"lines":[49,50]},"v":"Compliation","c":[{"t":"list_item","d":5,"p":{"lines":[51,52],"index":1},"v":"1. Compliation只负责其中的 编译 过程"},{"t":"list_item","d":5,"p":{"lines":[52,53],"index":2},"v":"2. Compliation只代表一次编译，也就是说，每当文件有变动，就重新生成一个Compliation实例，即一个文件结构"},{"t":"list_item","d":5,"p":{"lines":[53,54],"index":3},"v":"3. 一个Compilation对象包含了当前的模块资源、编译生成资源、变化的文件等"}]}]},{"t":"heading","d":2,"p":{"lines":[55,56]},"v":"bundle，chunk，module是什么","c":[{"t":"list_item","d":4,"p":{"lines":[59,60],"index":1},"v":"1. 对于一份同逻辑的代码，当我们手写下一个一个的文件，每个文件就是module"},{"t":"list_item","d":4,"p":{"lines":[60,61],"index":2},"v":"2. module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件"},{"t":"list_item","d":4,"p":{"lines":[61,62],"index":3},"v":"3. webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件"}]},{"t":"heading","d":2,"p":{"lines":[63,64]},"v":"运行流程","c":[{"t":"heading","d":3,"p":{"lines":[65,66]},"v":"初始化参数"},{"t":"heading","d":3,"p":{"lines":[69,70]},"v":"开始编译","c":[{"t":"list_item","d":5,"p":{"lines":[74,75],"index":1},"v":"1. 实例化Compiler对象，并且全局唯一，包含完整的webpack配置"},{"t":"list_item","d":5,"p":{"lines":[75,76],"index":2},"v":"2. 加载插件，调用插件的apply方法，使插件可以监听后续的事件节点"},{"t":"list_item","d":5,"p":{"lines":[76,77],"index":3},"v":"3. 应用node的文件系统至compiler对象，方便文件的寻找和读取"},{"t":"list_item","d":5,"p":{"lines":[77,78],"index":4},"v":"4. 确定入口，读取配置的Entrys"}]},{"t":"heading","d":3,"p":{"lines":[79,80]},"v":"编译模块","c":[{"t":"list_item","d":5,"p":{"lines":[83,84],"index":1},"v":"1. 获取文件路径entry"},{"t":"list_item","d":5,"p":{"lines":[84,85],"index":2},"v":"2. 通过entry读取模块内容entryContent"},{"t":"list_item","d":5,"p":{"lines":[85,86],"index":3},"v":"3. 调用babelLoader获取entryContent转化结果entrySource"},{"t":"list_item","d":5,"p":{"lines":[86,87],"index":4},"v":"4. 生成entryModule对象，并设置模块的id和source，然后推入modules中"}]},{"t":"heading","d":3,"p":{"lines":[88,89]},"v":"完成模块编译","c":[{"t":"list_item","d":5,"p":{"lines":[90,91],"index":1},"v":"1. 这里是修改输出内容的最后机会"},{"t":"list_item","d":5,"p":{"lines":[91,92],"index":2},"v":"2. 使用loader翻译完所有的模块后，得到每一个模块被翻译后的最终内容和他们的依赖关系"},{"t":"list_item","d":5,"p":{"lines":[92,93],"index":3},"v":"3. 根据入口和模块的依赖关系组成一个chunk"},{"t":"list_item","d":5,"p":{"lines":[93,94],"index":4},"v":"4. 把每个Chunk转化成一个单独的文件加入到输出列表中"}]},{"t":"heading","d":3,"p":{"lines":[95,96]},"v":"输出完成","c":[{"t":"list_item","d":5,"p":{"lines":[97,98],"index":1},"v":"1. 确定好输出内容后，确定输出的路径和文件名"},{"t":"list_item","d":5,"p":{"lines":[98,99],"index":2},"v":"2. 把文件内容写入到文件系统中"}]}]}]})</script>
</body>
</html>
