# 构造函数

构造函数位于src\core\instance\index.js

```JS
// vue的构造函数
function Vue(options) {
    //...
    this._init(options) // 默认调用init方法
}
// 原型属性处理
initMixin(Vue) // Vue.prototype._init
stateMixin(Vue) // $data $props $set $delete $watch
eventsMixin(Vue) // $on $emit $once 
lifecycleMixin(Vue) // Vue.prototype._update/Vue.prototype.$forceUpdate
renderMixin(Vue) // Vue.prototype.$nextTick/Vue.prototype._render
```

## Vue构造函数

创建一个Vue函数用于处理vue实例的创建

_init是在initMixin中设置的Vue.prototype._init

## 原型接口处理

都是在Vue.prototype上添加对应接口，在vue实例上可以获取使用

### initMixin

initMixin设置初始化相关接口

_init作用
1. 相关标识属性添加
2. options配置处理
3. 实例初始化处理（详细见笔记 02-初始化处理）
4. 组件挂载

```JS
export function initMixin(Vue) {
    //  Vue.prototype._init属性添加
    Vue.prototype._init = function(options) {
        const vm = this
        // 1. 标识_uid和标识为Vue实例，是不会被观测的
        vm._uid = uid++
        // ...
        vm._isVue = true
        // 2. options处理
        if (options && options._isComponent) {
            // 如果是组件，则会对组件配置进处理
            initInternalComponent(vm, options)
        } else {
            // Vue.options 和自己的属性合并
            vm.$options = mergeOptions(
                resolveConstructorOptions(vm.constructor),
                options || {},
                vm
            )
        }
        // ...
        // 3. 初始化处理
        vm._self = vm
        initLifecycle(vm)
        initEvents(vm)
        initRender(vm)
        callHook(vm, 'beforeCreate')
        initInjections(vm)
        initState(vm)
        initProvide(vm)
        callHook(vm, 'created')
        // ...
        // 4. 组件挂载
        if (vm.$options.el) {
            vm.$mount(vm.$options.el)
        }
    }
}
```

### stateMixin

stateMixin设置状态相关接口
1. $data和$props设置
2. $set和$delete设置
3. $watch设置

```JS
export function stateMixin(Vue) {
    // $data和$props设置
    // ...
    Object.defineProperty(Vue.prototype, '$data', dataDef)
    Object.defineProperty(Vue.prototype, '$props', propsDef)
    // $set和$delete设置
    Vue.prototype.$set = set
    Vue.prototype.$delete = del
    // $watch设置
    Vue.prototype.$watch = function(expOrFn, cb, options) {
        // ...
    }
}
```

#### $data和$props设置

简单将this._data和this._props设置为get并定义到Vue.prototype上

```JS
const dataDef = {}
dataDef.get = function() {
    return this._data
}
const propsDef = {}
propsDef.get = function() {
    return this._props
}
Object.defineProperty(Vue.prototype, '$data', dataDef)
Object.defineProperty(Vue.prototype, '$props', propsDef)
```

#### $set原理

1. 如果是数组，则直接执行splice方法处理
2. 如果是对象，先过滤不需要定义新属性的情形，否则使用defineReactive定义新值至ob.value，并通知更新

```JS
export function set(target, key, val) {
    // 如果是数组，则直接执行splice方法处理
    if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key)
        target.splice(key, 1, val)
        return val
    }
    // 如果为对象
    // 1. key存在，更新值
    if (key in target && !(key in Object.prototype)) {
        target[key] = val
        return val
    }
    const ob = (target).__ob__
    // 2. 如果修改是vue实例，则报错跳过
    if (target._isVue || (ob && ob.vmCount)) {
        process.env.NODE_ENV !== 'production' && warn(
            'Avoid adding reactive properties to a Vue instance or its root $data ' +
            'at runtime - declare it upfront in the data option.'
        )
        return val
    }
    // 3. 如果不是响应式对象，直接赋值
    if (!ob) {
        target[key] = val
        return val
    }
    // 4. 定义新响应式对象
    defineReactive(ob.value, key, val)
    ob.dep.notify()
    return val
}
```

#### $delete原理

1. 如果是数组，则直接执行splice方法处理
2. 如果是对象，先过滤异常和不存在情况，否则使用delete删除属性，并通知更新

```JS
export function del(target, key) {
    // 如果是数组，则直接执行splice方法处理
    if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.splice(key, 1)
        return
    }
    // 如果为对象
    const ob = (target).__ob__
    // 1. 如果修改是vue实例，则报错跳过
    if (target._isVue || (ob && ob.vmCount)) {
        process.env.NODE_ENV !== 'production' && warn(
            'Avoid deleting properties on a Vue instance or its root $data ' +
            '- just set it to null.'
        )
        return
    }
    // 2. 不存在对应key值，直接返回
    if (!hasOwn(target, key)) {
        return
    }
    // 3. delete删除属性，并触发更新
    delete target[key]
    if (!ob) {
        return
    }
    ob.dep.notify()
}
```

####  $watch设置

vue的watcher定义方式

```JS
Vue.prototype.$watch = function(expOrFn, cb, options) {
    const vm = this
    // 如果回调为空，则直接创建默认Watcher
    if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options)
    }
    // 用户自定义watcher创建
    options = options || {}
    options.user = true
    const watcher = new Watcher(vm, expOrFn, cb, options)
    // 如果immediate，则立即执行一次
    if (options.immediate) {
        const info = `callback for immediate watcher "${watcher.expression}"`
        pushTarget()
        invokeWithErrorHandling(cb, vm, [watcher.value], vm, info)
        popTarget()
    }
    // 返回清除当前watcher方法
    return function unwatchFn() {
        watcher.teardown()
    }
}
```

### eventsMixin

stateMixin设置事件相关接口
1. $on
2. $once
3. $off
4. $emit

```JS
export function eventsMixin(Vue) {
    const hookRE = /^hook:/
    Vue.prototype.$on = function(event, fn) {
        // ...
    }
    Vue.prototype.$once = function(event, fn) {
        // ...
    }
    Vue.prototype.$off = function(event, fn) {
        // ...
    }
    Vue.prototype.$emit = function(event) {
        // ...
    }
}
```

#### $on原理

创建监听

```JS
Vue.prototype.$on = function(event, fn) {
    const vm = this
    // 如果event是数组，则遍历每一项处理$on
    if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i < l; i++) {
            vm.$on(event[i], fn)
        }
    } else {
        // 将绑定的事件存储到vm._events中
        (vm._events[event] || (vm._events[event] = [])).push(fn)
        if (hookRE.test(event)) {
            vm._hasHookEvent = true
        }
    }
    return vm
}
```

#### $once原理

创建只执行一次的监听

```JS
Vue.prototype.$once = function(event, fn) {
    const vm = this
    // 创建on方法
    // 1. 移除监听
    // 2. 执行fn
    function on() {
        vm.$off(event, on)
        fn.apply(vm, arguments)
    }
    on.fn = fn
    // 向vue上注册on方法
    vm.$on(event, on)
    return vm
}
```

#### $off原理

移除监听

1. 不传递参数则直接清空监听
2. 不传fn，则event下的监听清空

```JS
Vue.prototype.$off = function(event, fn) {
    const vm = this
    // 1. 不传递参数则直接清空监听
    if (!arguments.length) {
        vm._events = Object.create(null)
        return vm
    }
    // 2. events是Array<string>列表处理，则遍历$off处理event[i]
    if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i < l; i++) {
            vm.$off(event[i], fn)
        }
        return vm
    }
    // 3. events是string处理
    const cbs = vm._events[event]
    // 没找到直接返回
    if (!cbs) {
        return vm
    }
    // 不传fn，则event下的监听清空
    if (!fn) {
        vm._events[event] = null
        return vm
    }
    // 遍历清除每个cb中对应的fn
    let cb
    let i = cbs.length
    while (i--) {
        cb = cbs[i]
        if (cb === fn || cb.fn === fn) {
            cbs.splice(i, 1)
            break
        }
    }
    return vm
}
```

#### $emit原理

触发回调处理，取出event对应的cbs，遍历执行

```JS
Vue.prototype.$emit = function(event) {
    const vm = this
    let cbs = vm._events[event]
    if (cbs) {
        // 将回调转化为数组
        cbs = cbs.length > 1 ? toArray(cbs) : cbs
        const args = toArray(arguments, 1)
        const info = `event handler for "${event}"`
        // 遍历执行回调
        for (let i = 0, l = cbs.length; i < l; i++) {
            invokeWithErrorHandling(cbs[i], vm, args, vm, info)
        }
    }
    return vm
}
```

### lifecycleMixin

lifecycleMixin设置渲染更新和组件销毁相关接口
1. _update
2. $forceUpdate
3. $destroy

```JS
export function lifecycleMixin(Vue) {
    Vue.prototype._update = function(vnode, hydrating) {
        // ...
    }

    Vue.prototype.$forceUpdate = function() {
        // ...
    }

    Vue.prototype.$destroy = function() {
        // ...
    }
}
```

#### _update原理

vue内部使用，用于处理实例渲染更新方法

详细见04-模板编译笔记

#### $forceUpdate原理

获取当前实例的_watcher，并调用其update

```JS
Vue.prototype.$forceUpdate = function() {
    const vm = this
    if (vm._watcher) {
        vm._watcher.update()
    }
}
```

#### $destroy原理

```JS
Vue.prototype.$destroy = function() {
    const vm = this
    // 拦截重复处理
    if (vm._isBeingDestroyed) {
        return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // 从父组件中移除自身
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm)
    }
    // 移除watcher监听
    if (vm._watcher) {
        vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
        vm._watchers[i].teardown()
    }
    // vmCount减一
    if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--
    }
    vm._isDestroyed = true
    // 渲染树清空
    vm.__patch__(vm._vnode, null)
    callHook(vm, 'destroyed')
    // 移除组件监听，详见$off原理
    vm.$off()
    // 移除 __vue__ 引用
    if (vm.$el) {
        vm.$el.__vue__ = null
    }
    // 清空虚拟节点的parent
    if (vm.$vnode) {
        vm.$vnode.parent = null
    }
}
```

### renderMixin

1. 安装渲染函数helpers处理
2. $nextTick
3. _render

```JS
export function renderMixin(Vue) {
    // 安装渲染函数helpers处理
    installRenderHelpers(Vue.prototype)
    // $nextTick
    Vue.prototype.$nextTick = function(fn) {
        return nextTick(fn, this)
    }
    // _render
    Vue.prototype._render = function() {
        // ...
    }
}
```

#### installRenderHelpers原理

将处理各种标签渲染的方法添加至Vue.prototype

```JS
export function installRenderHelpers(target: any) {
    target._o = markOnce
    target._n = toNumber
    target._s = toString
    target._l = renderList
    target._t = renderSlot
    target._q = looseEqual
    target._i = looseIndexOf
    target._m = renderStatic
    target._f = resolveFilter
    target._k = checkKeyCodes
    target._b = bindObjectProps
    target._v = createTextVNode
    target._e = createEmptyVNode
    target._u = resolveScopedSlots
    target._g = bindObjectListeners
    target._d = bindDynamicKeys
    target._p = prependModifier
}
```

#### $nextTick原理

用于处理实例异步更新后执行的方法

详细见06-异步更新笔记

#### _render原理

实例内部使用，_render处理vnode生成

详细见04-模板编译笔记
