# 组件生成和挂载

首先利用createElement中的createComponent创建vnode

然后patch时执行createElm中为组件执行createComponent执行创建

## 组件vnode获取

initRender时往实例上增加_c用于render调用vnode的生成

```JS
export function _createElement(
    context,
    tag,
    data,
    children,
    normalizationType
) {
    // ...
    let vnode, ns
    if (typeof tag === 'string') {
        // tag为标签的情况
        // ...
        if (config.isReservedTag(tag)) {
            // 基本元素标签处理
            // ...
        } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
            // 组件标签处理
            vnode = createComponent(Ctor, data, context, children, tag)
        } else {
            // 剩余情况处理
            // ...
        }
    } else {
        // tag为构造函数的情况
        vnode = createComponent(tag, data, context, children)
    }
    //...
}
```

_createElement中对组件触发createComponent获取组件的vnode
01.  Ctor获取和Ctor异常拦截
02.  异步组件按照异步组件处理并返回
03.  处理constructor的options
04.  v-model转化为props和events
05.  额外的props处理
06.  函数式组件处理
07.  组件监听事件和原生事件处理
08.  抽象组件相关处理
09.  添加hook，用于后续组件init
10. 组件的vnode创建

```JS
export function createComponent(
    Ctor,
    data,
    context,
    children,
    tag
) {
    // Ctor获取和Ctor异常拦截
    if (isUndef(Ctor)) {
        return
    }
    const baseCtor = context.$options._base
    if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor)
    }
    if (typeof Ctor !== 'function') {
        return
    }
    // 异步组件按照异步组件处理并返回
    // ...
    // 处理constructor的options
    resolveConstructorOptions(Ctor)
    // v-model转化为props和events
    if (isDef(data.model)) {
        transformModel(Ctor.options, data)
    }
    // 额外的props处理
    const propsData = extractPropsFromVNodeData(data, Ctor, tag)
    // 函数式组件处理
    // ...
    // 组件监听事件和原生事件处理
    const listeners = data.on
    data.on = data.nativeOn
    // 抽象组件相关处理
    // ...
    // 添加hook，用于后续组件init
    installComponentHooks(data)
    // 组件的vnode创建
    const name = Ctor.options.name || tag
    const vnode = new VNode( /// 创建虚拟节点 componentOptions 
        `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
        data, undefined, undefined, undefined, context, {
            Ctor,
            propsData,
            listeners,
            tag,
            children
        }, /// 包含组件的属性和事件 插槽作为children放在componentOptions上
        asyncFactory
    )
    return vnode
}
```

## 组件钩子合并

componentVNodeHooks的钩子将会由installComponentHook设置到组件的data.hook上

这里只详细介绍init的钩子处理

```JS
const componentVNodeHooks = {
    init(vnode, hydrating) {
        if (
            vnode.componentInstance &&
            !vnode.componentInstance._isDestroyed &&
            vnode.data.keepAlive // 有keepAlive标签，说明这个组件已经有了
        ) {
            // 组件已经存在，则patch组件，执行prepatch
            const mountedNode: any = vnode // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode)
        } else {
            // 根据组件实例创建vnode
            const child = vnode.componentInstance = createComponentInstanceForVnode(
                vnode,
                activeInstance // 当前激活的实例传入
            )
            // 组件挂载
            child.$mount(hydrating ? vnode.elm : undefined, hydrating)
        }
    },
    // 组件更新钩子
    prepatch(oldVnode, vnode) {},
    // 组件插入钩子
    insert(vnode) {},
    // 组件销毁钩子
    destroy(vnode) {}
}

export function createComponentInstanceForVnode(
    vnode,
    parent
) {
    // 处理相关配置
    // ...
    // 执行Ctor返回对应实例
    return new vnode.componentOptions.Ctor(options)
}
```

installComponentHooks增加钩子处理

```JS
function installComponentHooks(data) {
    const hooks = data.hook || (data.hook = {})
    for (let i = 0; i < hooksToMerge.length; i++) {
        const key = hooksToMerge[i]
        const existing = hooks[key]
        const toMerge = componentVNodeHooks[key]
        if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
        }
    }
}

function mergeHook(f1, f2) {
    const merged = (a, b) => {
        f1(a, b)
        f2(a, b)
    }
    merged._merged = true
    return merged
}
```

## 组件挂载处理

组件挂载则是在patch中处理，patch会调用createElm方法进行组件的创建

当vnode未组件时则会createComponent执行创建

```JS
function createElm(
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
) {
    // ...
    // 检测时否是组件，如果是组件测创建组件
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return
    }
    // ...
}

function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    // 获取i
    let i = vnode.data
    if (isDef(i)) {
        const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
        // i.hook或者i.init存在，则执行创建组件
        if (isDef(i = i.hook) && isDef(i = i.init)) {
            i(vnode, false /* hydrating */ )
        }
        // 判断vnode.componentInstance是否存在得出组件是否成功创建
        if (isDef(vnode.componentInstance)) {
            initComponent(vnode, insertedVnodeQueue)
            insert(parentElm, vnode.elm, refElm)
            if (isTrue(isReactivated)) {
                reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
            }
            return true
        }
    }
}
```
