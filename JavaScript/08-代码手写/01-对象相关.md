# 对象相关

## 对象原理

### new

```js
function _new(fn, args) {
    if (typeof fn !== 'function') {
        throw TypeError('fn is not function')
    }
    let obj = new Object()
    obj.__proto__ = fn.prototype
    let res = fn.apply(obj, args)
    return typeof res == 'object' ? res : obj
}
```

### Object.create

```js
Object._create = function(obj) {
    function Fn() {}
    Fn.prototype = obj
    return new Fn()
}
```

### instanceof

```js
function _instanceof(left, right) {
    let proto = Object.getPrototypeOf(left)
    prototype = right.prototype
    while (proto) {
        if (proto === prototype) {
            return true
        }
        proto = Object.getPrototypeOf(proto);
    }
    return false
}
```

### typeof

```js
function _typeOf(obj) {
    let type = typeof obj
    if (type !== 'object') return type
    // slice 参数为负数则返回从后向前的数组
    return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
}
```

## 面向对象

### 创建对象

#### 1. 工厂模式

```js
function createPerson(name) {
    let preson = {}
    preson.name = name
    preson.sayName = function() {
        console.log('我叫' + this.name)
    }
    return preson
}
let fp = createPerson('zfl')
```

#### 2. 构造函数模式

```js
function Preson(name) {
    this.name = name
    this.sayName = function() {
        console.log('我叫' + this.name)
    }
}
let cp = new Preson('zfl')
```

#### 3. 原型模式

```js
function Preson() {}
Preson.prototype.name = 'zfl'
Preson.prototype.sayName = function() {
    console.log('我叫' + this.name)
}
let pp = new Preson('zfl')
```

#### 4. 组合使用构造函数模式和原型模式

```js
function Preson(name) {
    this.name = name
}
Preson.prototype.sayName = function() {
    console.log('我叫' + this.name)
}
let cpp = new Preson('zfl')
```

#### 5. 动态原型模式

```js
function Preson(name) {
    this.name = name
    if (typeof this.sayName !== 'function') {
        Preson.prototype.sayName = function() {
            console.log('我叫' + this.name)
        }
    }
}
let acpp = new Preson('zfl')
```

#### 6. 寄生构造函数模式（不推荐）

```js
// 只是工厂函数调用new
let pfp = new createPerson('zfl')
```

#### 7. 稳妥构造函数模式（不推荐）

```js
function secureCreatePerson(name) {
    let preson = {}
    preson.name = name
    preson.sayName = function() {
        console.log('我叫' + name) // 不使用this
    }
    return preson
}
let sp = secureCreatePerson('zfl') // 不使用new
```

### 继承对象

#### 1. 原型链

```js
function Parent() {
    this.attr = {
        eye: 'blue',
        hair: 'black',
        skin: 'white',
    };
    this.sayName = function() {
        console.log('Name');
    };
}

function Child() {
    this.sayHi = function() {
        console.log('Hello world!');
    };
}
Child.prototype = new Parent()
```

#### 2. 借用构造函数

```js
function Parent(name) {
    this.name = name;
}

function Child() {
    //继承了 Parent，同时还传递了参数
    Parent.call(this, 'Uzi');
    //实例属性
    this.age = 18;
}
```

#### 3. 组合继承

```js
function Parent(name) {
    this.name = name;
    this.attr = {
        eye: 'blue',
        hair: 'black',
        skin: 'white',
    };
}
Parent.prototype.sayName = function() {
    console.log(this.name);
};

function Child(name, age) {
    Parent.call(this, name);
    this.age = age;
}
Child.prototype = new Parent();
Child.prototype.constructor = Child; // constructor指向问题
Child.prototype.sayAge = function() {
    console.log(this.age);
};
```

#### 4. 原型式继承（Object.create()原理）

```js
function Person(friendship) {
    function Creator() {}
    Creator.prototype = friendship;
    return new Creator();
}
```

#### 5. 寄生式继承

```js
function creator(origin) {
    let clone = Object.create(origin);
    clone.sayHi = function() {
        console.log('Hello world!');
    };
    return clone;
}
```

#### 6. 寄生组合式继承（首选）

```js
function inherit(children, parent) {
    // 创建对象
    let prototype = Object.create(parent.prototype);
    // 增强对象
    prototype.constructor = children;
    // 指定对象
    children.prototype = prototype;
}

function Parent(name) {
    this.name = name;
    this.num = [0, 1, 2];
}
Parent.prototype.sayName = function() {
    alert(this.name);
};

function Child(name, age) {
    // 父类自身属性继承
    Parent.call(this, name);
    this.age = age;
}
inherit(Child, Parent);
```

## 深浅拷贝

```js
function objectCopy(obj, deep = false) {
    if (typeof obj !== 'object') return obj
    let newObj = obj instanceof Array ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            let element = obj[key]
            newObj[key] = deep && typeof element === 'object' ? objectCopy(element, deep) : element
        }
    }
    return newObj
}
```

## 对象是否循环使用

```js
const isCycleObject = (obj, parent) => {
    const parentArr = parent || [obj];
    for (let i in obj) {
        if (typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) => {
                if (pObj === obj[i]) {
                    flag = true;
                }
            })
            if (flag) return true;
            flag = isCycleObject(obj[i], [...parentArr, obj[i]]);
            if (flag) return true;
        }
    }
    return false;
}
```
