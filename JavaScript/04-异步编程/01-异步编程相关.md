# 异步编程相关

首先想理解异步编程，需要首先去理解浏览器事件循环和宏/微任务

1. 回调函数
2. Promise
3. async/await

## 回调函数

回调函数就是将函数作为参数传入调用函数，当处理完成时执行回调函数

但是回调函数存在回调地狱

### 回调地狱

多层嵌套回调，不利于后期维护

解决方式
1. Promise的链式调用
2. async/await的同步执行

### 定时执行函数

#### 定时器触发线程控制

setInterval与setTimeout

1. 同步代码会阻塞执行
2. setInterval存在执行积累的问题，无法保证准确时间执行

```JS
function demo() {
    setInterval(function() {
        console.log(2)
    }, 1000)
    sleep(2000)
}
demo()
```

#### GUI渲染线程控制

window.requestAnimationFrame是浏览器渲染进程控制的一个异步回调接口

利用cancelAnimationFrame()，传入requestAnimationFrame返回的id取消执行

##### requestAnimationFrame执行时机

浏览器按照屏幕帧率每一帧执行一次重绘，一般为60帧，16.7ms执行一次，该函数会在下一次浏览器重绘时执行

##### requestAnimationFrame与定时器差异

1. 执行控制：定时器是定时器线程和事件队列控制，requestAnimationFrame由浏览器渲染控制
2. 是否暂停：RAF会在标签和iframe隐藏时停止执行，定时器会一直执行

##### requestAnimationFrame处理动画优势(比较定时器)

1. 函数节流：保证每个刷新间隔内，函数只被执行一次
2. CPU节能：RAF会自动暂停执行
3. 减少DOM操作：将一帧中的所有操作集合起来，并在一次回流或重绘完成
4. 执行准时且合适：定时器存在延迟执行和执行积累问题，无法保证和浏览器刷新时间一致造成丢帧

##### requestAnimationFrame替代定时器

```JS
function setInterval(callback, interval) {
    let timer
    const now = Date.now
    let startTime = now()
    let endTime = startTime
    const loop = () => {
        timer = window.requestAnimationFrame(loop)
        endTime = now()
        if (endTime - startTime >= interval) {
            startTime = endTime = now()
            callback(timer)
        }
    }
    timer = window.requestAnimationFrame(loop)
    return timer
}
```

## Promise和async/await

详见后续文档
