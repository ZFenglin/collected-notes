# 初始化处理

initMixin中注册的_init是vue实例初始化的方法

```JS
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm)
initState(vm)
initProvide(vm)
callHook(vm, 'created')
```

## initLifecycle

初始化组件的父子关系

```JS
export function initLifecycle(vm) {
    const options = vm.$options
    let parent = options.parent
    // 寻找至不是抽象组件的上一级
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent
        }
        // $children添加
        parent.$children.push(vm)
    }
    // $parents设置
    vm.$parent = parent
    // $root设置
    vm.$root = parent ? parent.$root : vm
    // $children设置
    vm.$children = []
    // $refs设置
    vm.$refs = {}
    // 其他属性设置
    vm._watcher = null
    vm._inactive = null
    vm._directInactive = false
    vm._isMounted = false
    vm._isDestroyed = false
    vm._isBeingDestroyed = false
}
```

## initEvents

处理组件间事件的发布订阅

```JS
export function initEvents(vm) {
    // 当前实例创建_events，作为发布订阅的收集
    vm._events = Object.create(null)
    vm._hasHookEvent = false
    // 初始化parent连接时间
    const listeners = vm.$options._parentListeners
    if (listeners) {
        updateComponentListeners(vm, listeners)
    }
}
```

## initRender

渲染相关接口处理
1. 初始化插槽
2. _c和$createElement
3. $attrs和$listeners

```JS
export function initRender(vm) {
    vm._vnode = null
    // v-once的缓存树
    vm._staticTrees = null
    const options = vm.$options
    const parentVnode = vm.$vnode = options._parentVnode
    const renderContext = parentVnode && parentVnode.context
    // vm.$scopedSlots和 vm.$slots设置
    vm.$slots = resolveSlots(options._renderChildren, renderContext)
    vm.$scopedSlots = emptyObject
    // vm._c和vm.$createElement设置
    vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false) // false 内部编译使用_c
    vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true) // true 外部编译使用$createElement
    const parentData = parentVnode && parentVnode.data
    // 定义$attrs和$listeners
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true)
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true)
}
```

## initInjections

inject处理

隔代传输数据，不建议开发使用，因为值不清楚由谁提供、

```JS
export function initInjections(vm) {
    const result = resolveInject(vm.$options.inject, vm)
    if (result) {
        // 数据观测开关关闭
        toggleObserving(false)
        /// 将当前获取到的Inject定义到当前实例上
        Object.keys(result).forEach(key => {
            // ...
            defineReactive(vm, key, result[key])
        })
        // 数据观测开关开启
        toggleObserving(true)
    }
}
```

inject的获取就是不断访问当前实例上的$parent，直到实例的provider有inject对应的key

```JS
export function resolveInject(inject, vm) {
    if (inject) {
        const result = Object.create(null)
        // 获取inject的keys
        const keys = hasSymbol ?
            Reflect.ownKeys(inject) :
            Object.keys(inject)

        for (let i = 0; i < keys.length; i++) {
            const key = keys[i]
            if (key === '__ob__') continue
            const provideKey = inject[key].from
            let source = vm
            // 不停往上查找source的祖先中的provider，直到找到为止
            while (source) {
                if (source._provided && hasOwn(source._provided, provideKey)) {
                    result[key] = source._provided[provideKey]
                    break
                }
                source = source.$parent
            }
            if (!source) {
                // 未找到处理
                // ...
            }
        }
        return result
    }
}
```

## initState

处理props和data等数据

```JS
export function initState(vm) {
    // 收集当前实例上的所有watcher，用于$forceUpdate使用
    vm._watchers = []
    const opts = vm.$options
    // 组件的属性原理 vm._props
    if (opts.props) initProps(vm, opts.props)
    // 将方所有的方法定义在vm._methods上，并且把方法的this指向当前实例
    if (opts.methods) initMethods(vm, opts.methods)
    // data数据初始化
    if (opts.data) {
        initData(vm)
    } else {
        observe(vm._data = {}, true)
    }
    // computed初始化处理
    if (opts.computed) initComputed(vm, opts.computed)
    // watch初始化处理
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch)
    }
}
```

### initProps

props初始化，在当前实例的_props上设置传入值

```JS
function initProps(vm, propsOptions) {
    const propsData = vm.$options.propsData || {}
    // vm._props用于接收对应对象
    const props = vm._props = {}
    const keys = vm.$options._propKeys = []
    const isRoot = !vm.$parent
    if (!isRoot) {
        // 如果是根节点，则关闭数据监听
        toggleObserving(false)
    }
    for (const key in propsOptions) {
        keys.push(key)
        // 获取校验过的value
        const value = validateProp(key, propsOptions, propsData, vm)
        // 将对应的value和key定义到props上
        defineReactive(props, key, value)
        // 代理_props属性值vue实例上
        if (!(key in vm)) {
            proxy(vm, `_props`, key)
        }
    }
    // 开启数据监听
    toggleObserving(true)
}
```

### initMethods

methods初始化

获取methods绑定this至vm的处理函数

将函数赋值到vm对应的key上

```JS
function initMethods(vm, methods) {
    for (const key in methods) {
        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm)
    }
}
```

### initData

data初始化处理
1. 获取data
2. data代理至vm
3. data响应式处理

```JS
function initData(vm) {
    let data = vm.$options.data
    // 1. data获取处理
    data = vm._data = typeof data === 'function' ?
        getData(data, vm) :
        data || {}
    if (!isPlainObject(data)) {
        data = {}
    }
    // proxy data on instance
    const keys = Object.keys(data)
    const props = vm.$options.props
    const methods = vm.$options.methods
    let i = keys.length
    // 2. 代理data至vm
    while (i--) {
        const key = keys[i]
        if (props && hasOwn(props, key)) {
            // props冲突报错
        } else if (!isReserved(key)) {
            proxy(vm, `_data`, key)
        }
    }
    // 3. data响应式处理
    observe(data, true /* asRootData */ )
}
```

### initComputed 和 initWatch

初始化computed和watch

详细见（TODO）Computed和Watch笔记

## initProvide

provider处理

简单处理provider赋值，如果是function则获取执行结果

此处可以看出provider并不是响应式的数据

```JS
export function initProvide(vm) {
    const provide = vm.$options.provide
    if (provide) {
        vm._provided = typeof provide === 'function' ?
            provide.call(vm) :
            provide
    }
}
```
