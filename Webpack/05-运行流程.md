# 运行流程

## 初始化参数

从配置文件和shell中读取和合并参数，并得出最终参数

## 开始编译

### 实例化Compiler对象

Webpack启动时实例化，并且全局唯一，包含完整的webpack配置
1. options
2. laoders
3. plugins

Compiler作用如下
1. 文件监听
2. 启动编译

### 加载插件

依次调用插件的apply方法，使插件可以监听后续的事件节点

同时传入compiler实例，方便插件调用webpack的API

### environment

应用node的文件系统至compiler对象，方便文件的寻找和读取

### 确定入口

entry-option，读取配置的Entrys

为每个Entry实例化一个对应的EntryPlugin，为Entry的递归解析作准备

### after-plugins

调用完所有内置和配置的apply的方法

### after-resolvers

配置初始化的resolver（resolver负责在文件系统中寻找指定路径文件）

## 编译模块

### run

启动新的编译

### watch-run

类似run，只是在监听模式下启动

### compile

告诉插件一次新的编译将要启动，给插件带上compiler对象

### compilation

开发模式下运行时，每次文件变化，就有新的Compilation被创建

提供很多事件回调供插件扩展，同时也能读取到Compilation对象

#### compilation包含内容

1. 当前模块资源
2. 编译生成资源
3. 变化的文件

#### compilation步骤

##### build-module

使用对应Loader去转换模块

##### normal-module-loader

模块转换后。使用acorn解析内容生成AST

##### 完成模块编译

1. program：从入口配置开始，分析AST，遇见require等导入其它模块，将其加入到模块列表中。对新找出的依赖模块递归分析，找出所有的模块的依赖关系
2. seal：所有模块根据Loader转化完成，根据依赖生成Chunk

### make

新的Compilation创建后，从Entry读取文件，根据文件类型和Loader对文件进行递归编译

### after-compile

一次Compilation执行完

### invalid

文件不存在，文件编译错误等异常时触发这个事件，不会中断webpack执行

## 输出完成

### should-emit

所有需要输出的文件已经生成，询问插件有哪些文件需要输出

### emit

确定号要输出的文件，执行文件输出

此处为最后修改文件内容机会

### after-emit

文件输出完成

### done

完成一次完整的编译和输出流程

### failed

编译过程中造成webpack退出异常，则执行此方法
