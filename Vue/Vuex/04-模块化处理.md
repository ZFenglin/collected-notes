# 模块化处理


## Module

```JS
export default class Module {
    constructor(rawModule, runtime) {
        this.runtime = runtime
        this._children = Object.create(null)
        this._rawModule = rawModule
        const rawState = rawModule.state
        this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}
    }
    // 判断是否设置namespace
    get namespaced() {
        return !!this._rawModule.namespaced
    }
    // 孩子相关方法
    // ...
    // 更新模块
    // ...
    // 遍历处理
    // ...
}
```

### 孩子相关方法

```JS
addChild(key, module) {
    this._children[key] = module
}

removeChild(key) {
    delete this._children[key]
}

getChild(key) {
    return this._children[key]
}

hasChild(key) {
    return key in this._children
}
```

### 更新模块

```JS
update(rawModule) {
    this._rawModule.namespaced = rawModule.namespaced
    if (rawModule.actions) {
        this._rawModule.actions = rawModule.actions
    }
    if (rawModule.mutations) {
        this._rawModule.mutations = rawModule.mutations
    }
    if (rawModule.getters) {
        this._rawModule.getters = rawModule.getters
    }
}
```

### 遍历处理

```JS
forEachChild(fn) {
    forEachValue(this._children, fn)
}

forEachGetter(fn) {
    if (this._rawModule.getters) {
        forEachValue(this._rawModule.getters, fn)
    }
}

forEachAction(fn) {
    if (this._rawModule.actions) {
        forEachValue(this._rawModule.actions, fn)
    }
}

forEachMutation(fn) {
    if (this._rawModule.mutations) {
        forEachValue(this._rawModule.mutations, fn)
    }
}
```

#### forEachValue

```JS
export function forEachValue(obj, fn) {

    Object.keys(obj).forEach(key => fn(obj[key], key))

}
```

## ModuleCollection

```JS
export default class ModuleCollection {
    constructor(rawRootModule) {
        this.register([], rawRootModule, false)
    }

    get(path) {
        return path.reduce((module, key) => {
            return module.getChild(key)
        }, this.root)
    }

    getNamespace(path) {
        let module = this.root
        return path.reduce((namespace, key) => {
            module = module.getChild(key)
            return namespace + (module.namespaced ? key + '/' : '')
        }, '')
    }

    update(rawRootModule) {
        update([], this.root, rawRootModule)
    }

    register(path, rawModule, runtime = true) {
        const newModule = new Module(rawModule, runtime)
        if (path.length === 0) {
            this.root = newModule
        } else {
            const parent = this.get(path.slice(0, -1))
            parent.addChild(path[path.length - 1], newModule)
        }

        // register nested modules
        if (rawModule.modules) {
            forEachValue(rawModule.modules, (rawChildModule, key) => {
                this.register(path.concat(key), rawChildModule, runtime)
            })
        }
    }

    unregister(path) {
        const parent = this.get(path.slice(0, -1))
        const key = path[path.length - 1]
        const child = parent.getChild(key)

        if (!child) {
            return
        }

        if (!child.runtime) {
            return
        }

        parent.removeChild(key)
    }

    isRegistered(path) {
        const parent = this.get(path.slice(0, -1))
        const key = path[path.length - 1]

        if (parent) {
            return parent.hasChild(key)
        }

        return false
    }
}
```
